{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-grid",
  "type": "registry:component",
  "title": "Data Grid",
  "description": "A high-performance editable data grid component with virtualization, keyboard navigation, and cell editing",
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/react-virtual",
    "lucide-react",
    "sonner"
  ],
  "registryDependencies": [
    "badge",
    "button",
    "calendar",
    "checkbox",
    "command",
    "dialog",
    "dropdown-menu",
    "input",
    "kbd",
    "popover",
    "select",
    "separator",
    "textarea",
    "tooltip"
  ],
  "files": [
    {
      "path": "src/components/data-grid/data-grid.tsx",
      "content": "\"use client\";\r\n\r\nimport { flexRender } from \"@tanstack/react-table\";\r\nimport { Plus } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { DataGridColumnHeader } from \"@/components/data-grid/data-grid-column-header\";\r\nimport { DataGridContextMenu } from \"@/components/data-grid/data-grid-context-menu\";\r\nimport { DataGridKeyboardShortcuts } from \"@/components/data-grid/data-grid-keyboard-shortcuts\";\r\nimport { DataGridRow } from \"@/components/data-grid/data-grid-row\";\r\nimport { DataGridSearch } from \"@/components/data-grid/data-grid-search\";\r\nimport type { useDataGrid } from \"@/hooks/use-data-grid\";\r\nimport { getCommonPinningStyles } from \"@/lib/data-table\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport type { CellPosition } from \"@/types/data-grid\";\r\n\r\ninterface DataGridProps<TData>\r\n  extends ReturnType<typeof useDataGrid<TData>>,\r\n    React.ComponentProps<\"div\"> {\r\n  height?: number;\r\n  onRowAdd?: (event?: React.MouseEvent<HTMLDivElement>) =>\r\n    | Partial<CellPosition>\r\n    | Promise<Partial<CellPosition>>\r\n    | null\r\n    // biome-ignore lint/suspicious/noConfusingVoidType: void is needed here to allow functions without explicit return\r\n    | void;\r\n}\r\n\r\nexport function DataGrid<TData>({\r\n  dataGridRef,\r\n  headerRef,\r\n  rowMapRef,\r\n  footerRef,\r\n  table,\r\n  rowVirtualizer,\r\n  height = 600,\r\n  searchState,\r\n  columnSizeVars,\r\n  scrollToRow,\r\n  onRowAdd: onRowAddProp,\r\n  className,\r\n  ...props\r\n}: DataGridProps<TData>) {\r\n  const rows = table.getRowModel().rows;\r\n  const columns = table.getAllColumns();\r\n\r\n  const meta = table.options.meta;\r\n  const rowHeight = meta?.rowHeight ?? \"short\";\r\n  const focusedCell = meta?.focusedCell ?? null;\r\n\r\n  const onGridContextMenu = React.useCallback(\r\n    (event: React.MouseEvent<HTMLDivElement>) => {\r\n      event.preventDefault();\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onRowAdd = React.useCallback(\r\n    async (event?: React.MouseEvent<HTMLDivElement>) => {\r\n      if (!onRowAddProp) return;\r\n\r\n      const result = await onRowAddProp();\r\n\r\n      if (event?.defaultPrevented || result === null) return;\r\n\r\n      if (result) {\r\n        const adjustedRowIndex =\r\n          (result.rowIndex ?? 0) >= rows.length ? rows.length : result.rowIndex;\r\n\r\n        scrollToRow({\r\n          rowIndex: adjustedRowIndex,\r\n          columnId: result.columnId,\r\n        });\r\n        return;\r\n      }\r\n\r\n      scrollToRow({ rowIndex: rows.length });\r\n    },\r\n    [onRowAddProp, scrollToRow, rows.length],\r\n  );\r\n\r\n  const onAddRowKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (!onRowAddProp) return;\r\n\r\n      if (event.key === \"Enter\" || event.key === \" \") {\r\n        event.preventDefault();\r\n        onRowAdd();\r\n      }\r\n    },\r\n    [onRowAddProp, onRowAdd],\r\n  );\r\n\r\n  return (\r\n    <div\r\n      data-slot=\"grid-wrapper\"\r\n      className={cn(\"relative flex w-full flex-col\", className)}\r\n      {...props}\r\n    >\r\n      {searchState && <DataGridSearch {...searchState} />}\r\n      <DataGridKeyboardShortcuts enableSearch={!!searchState} />\r\n      <DataGridContextMenu table={table} />\r\n      <div\r\n        role=\"grid\"\r\n        aria-label=\"Data grid\"\r\n        aria-rowcount={rows.length + (onRowAddProp ? 1 : 0)}\r\n        aria-colcount={columns.length}\r\n        data-slot=\"grid\"\r\n        tabIndex={0}\r\n        ref={dataGridRef}\r\n        className=\"relative grid select-none overflow-auto rounded-md border focus:outline-none\"\r\n        style={{\r\n          ...columnSizeVars,\r\n          height: `${height}px`,\r\n        }}\r\n        onContextMenu={onGridContextMenu}\r\n      >\r\n        <div\r\n          role=\"rowgroup\"\r\n          data-slot=\"grid-header\"\r\n          ref={headerRef}\r\n          className=\"sticky top-0 z-10 grid border-b bg-background\"\r\n        >\r\n          {table.getHeaderGroups().map((headerGroup, rowIndex) => (\r\n            <div\r\n              key={headerGroup.id}\r\n              role=\"row\"\r\n              aria-rowindex={rowIndex + 1}\r\n              data-slot=\"grid-header-row\"\r\n              tabIndex={-1}\r\n              className=\"flex w-full\"\r\n            >\r\n              {headerGroup.headers.map((header, colIndex) => {\r\n                const sorting = table.getState().sorting;\r\n                const currentSort = sorting.find(\r\n                  (sort) => sort.id === header.column.id,\r\n                );\r\n                const isSortable = header.column.getCanSort();\r\n\r\n                return (\r\n                  <div\r\n                    key={header.id}\r\n                    role=\"columnheader\"\r\n                    aria-colindex={colIndex + 1}\r\n                    aria-sort={\r\n                      currentSort?.desc === false\r\n                        ? \"ascending\"\r\n                        : currentSort?.desc === true\r\n                          ? \"descending\"\r\n                          : isSortable\r\n                            ? \"none\"\r\n                            : undefined\r\n                    }\r\n                    data-slot=\"grid-header-cell\"\r\n                    tabIndex={-1}\r\n                    className={cn(\"relative\", {\r\n                      \"border-r\": header.column.id !== \"select\",\r\n                    })}\r\n                    style={{\r\n                      ...getCommonPinningStyles({ column: header.column }),\r\n                      width: `calc(var(--header-${header.id}-size) * 1px)`,\r\n                    }}\r\n                  >\r\n                    {header.isPlaceholder ? null : typeof header.column\r\n                        .columnDef.header === \"function\" ? (\r\n                      <div className=\"size-full px-3 py-1.5\">\r\n                        {flexRender(\r\n                          header.column.columnDef.header,\r\n                          header.getContext(),\r\n                        )}\r\n                      </div>\r\n                    ) : (\r\n                      <DataGridColumnHeader header={header} table={table} />\r\n                    )}\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          ))}\r\n        </div>\r\n        <div\r\n          role=\"rowgroup\"\r\n          data-slot=\"grid-body\"\r\n          className=\"relative grid\"\r\n          style={{\r\n            height: `${rowVirtualizer.getTotalSize()}px`,\r\n          }}\r\n        >\r\n          {rowVirtualizer.getVirtualIndexes().map((virtualRowIndex) => {\r\n            const row = rows[virtualRowIndex];\r\n            if (!row) return null;\r\n\r\n            return (\r\n              <DataGridRow\r\n                key={row.id}\r\n                row={row}\r\n                rowMapRef={rowMapRef}\r\n                virtualRowIndex={virtualRowIndex}\r\n                rowVirtualizer={rowVirtualizer}\r\n                rowHeight={rowHeight}\r\n                focusedCell={focusedCell}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n        {onRowAdd && (\r\n          <div\r\n            role=\"rowgroup\"\r\n            data-slot=\"grid-footer\"\r\n            ref={footerRef}\r\n            className=\"sticky bottom-0 z-10 grid border-t bg-background\"\r\n          >\r\n            <div\r\n              role=\"row\"\r\n              aria-rowindex={rows.length + 2}\r\n              data-slot=\"grid-add-row\"\r\n              tabIndex={-1}\r\n              className=\"flex w-full\"\r\n            >\r\n              <div\r\n                role=\"gridcell\"\r\n                tabIndex={0}\r\n                className=\"relative flex h-9 grow items-center bg-muted/30 transition-colors hover:bg-muted/50 focus:bg-muted/50 focus:outline-none\"\r\n                style={{\r\n                  width: table.getTotalSize(),\r\n                  minWidth: table.getTotalSize(),\r\n                }}\r\n                onClick={onRowAdd}\r\n                onKeyDown={onAddRowKeyDown}\r\n              >\r\n                <div className=\"sticky left-0 flex items-center gap-2 px-3 text-muted-foreground\">\r\n                  <Plus className=\"size-3.5\" />\r\n                  <span className=\"text-sm\">Add row</span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-cell.tsx",
      "content": "\"use client\";\r\n\r\nimport type { Cell, Table } from \"@tanstack/react-table\";\r\nimport * as React from \"react\";\r\n\r\nimport {\r\n  CheckboxCell,\r\n  DateCell,\r\n  LongTextCell,\r\n  MultiSelectCell,\r\n  NumberCell,\r\n  SelectCell,\r\n  ShortTextCell,\r\n} from \"@/components/data-grid/data-grid-cell-variants\";\r\n\r\ninterface DataGridCellProps<TData> {\r\n  cell: Cell<TData, unknown>;\r\n  table: Table<TData>;\r\n}\r\n\r\nexport function DataGridCell<TData>({ cell, table }: DataGridCellProps<TData>) {\r\n  const meta = table.options.meta;\r\n  const originalRowIndex = cell.row.index;\r\n\r\n  const rows = table.getRowModel().rows;\r\n  const displayRowIndex = rows.findIndex(\r\n    (row) => row.original === cell.row.original,\r\n  );\r\n  const rowIndex = displayRowIndex >= 0 ? displayRowIndex : originalRowIndex;\r\n  const columnId = cell.column.id;\r\n\r\n  const isFocused =\r\n    meta?.focusedCell?.rowIndex === rowIndex &&\r\n    meta?.focusedCell?.columnId === columnId;\r\n  const isEditing =\r\n    meta?.editingCell?.rowIndex === rowIndex &&\r\n    meta?.editingCell?.columnId === columnId;\r\n  const isSelected = meta?.getIsCellSelected?.(rowIndex, columnId) ?? false;\r\n\r\n  const cellOpts = cell.column.columnDef.meta?.cell;\r\n  const variant = cellOpts?.variant ?? \"text\";\r\n\r\n  switch (variant) {\r\n    case \"short-text\":\r\n      return (\r\n        <ShortTextCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n    case \"long-text\":\r\n      return (\r\n        <LongTextCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n    case \"number\":\r\n      return (\r\n        <NumberCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n    case \"select\":\r\n      return (\r\n        <SelectCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n    case \"multi-select\":\r\n      return (\r\n        <MultiSelectCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n    case \"checkbox\":\r\n      return (\r\n        <CheckboxCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n    case \"date\":\r\n      return (\r\n        <DateCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n\r\n    default:\r\n      return (\r\n        <ShortTextCell\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n        />\r\n      );\r\n  }\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-cell.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-cell-wrapper.tsx",
      "content": "\"use client\";\r\n\r\nimport type { Cell, Table } from \"@tanstack/react-table\";\r\nimport * as React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface DataGridCellWrapperProps<TData> extends React.ComponentProps<\"div\"> {\r\n  cell: Cell<TData, unknown>;\r\n  table: Table<TData>;\r\n  rowIndex: number;\r\n  columnId: string;\r\n  isEditing: boolean;\r\n  isFocused: boolean;\r\n  isSelected: boolean;\r\n}\r\n\r\nexport function DataGridCellWrapper<TData>({\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isEditing,\r\n  isFocused,\r\n  isSelected,\r\n  className,\r\n  onClick: onClickProp,\r\n  onKeyDown: onKeyDownProp,\r\n  ...props\r\n}: DataGridCellWrapperProps<TData>) {\r\n  const meta = table.options.meta;\r\n\r\n  const isSearchMatch = meta?.getIsSearchMatch?.(rowIndex, columnId) ?? false;\r\n  const isActiveSearchMatch =\r\n    meta?.getIsActiveSearchMatch?.(rowIndex, columnId) ?? false;\r\n\r\n  const onClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLDivElement>) => {\r\n      if (!isEditing) {\r\n        event.preventDefault();\r\n        onClickProp?.(event);\r\n        if (isFocused) {\r\n          meta?.onCellEditingStart?.(rowIndex, columnId);\r\n        } else {\r\n          meta?.onCellClick?.(rowIndex, columnId, event);\r\n        }\r\n      }\r\n    },\r\n    [meta, rowIndex, columnId, isEditing, isFocused, onClickProp],\r\n  );\r\n\r\n  const onContextMenu = React.useCallback(\r\n    (event: React.MouseEvent) => {\r\n      if (!isEditing) {\r\n        meta?.onCellContextMenu?.(rowIndex, columnId, event);\r\n      }\r\n    },\r\n    [meta, rowIndex, columnId, isEditing],\r\n  );\r\n\r\n  const onMouseDown = React.useCallback(\r\n    (event: React.MouseEvent) => {\r\n      if (!isEditing) {\r\n        meta?.onCellMouseDown?.(rowIndex, columnId, event);\r\n      }\r\n    },\r\n    [meta, rowIndex, columnId, isEditing],\r\n  );\r\n\r\n  const onMouseEnter = React.useCallback(\r\n    (event: React.MouseEvent) => {\r\n      if (!isEditing) {\r\n        meta?.onCellMouseEnter?.(rowIndex, columnId, event);\r\n      }\r\n    },\r\n    [meta, rowIndex, columnId, isEditing],\r\n  );\r\n\r\n  const onMouseUp = React.useCallback(() => {\r\n    if (!isEditing) {\r\n      meta?.onCellMouseUp?.();\r\n    }\r\n  }, [meta, isEditing]);\r\n\r\n  const onDoubleClick = React.useCallback(\r\n    (event: React.MouseEvent) => {\r\n      if (!isEditing) {\r\n        event.preventDefault();\r\n        meta?.onCellDoubleClick?.(rowIndex, columnId);\r\n      }\r\n    },\r\n    [meta, rowIndex, columnId, isEditing],\r\n  );\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      onKeyDownProp?.(event);\r\n\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (\r\n        event.key === \"ArrowUp\" ||\r\n        event.key === \"ArrowDown\" ||\r\n        event.key === \"ArrowLeft\" ||\r\n        event.key === \"ArrowRight\" ||\r\n        event.key === \"Home\" ||\r\n        event.key === \"End\" ||\r\n        event.key === \"PageUp\" ||\r\n        event.key === \"PageDown\" ||\r\n        event.key === \"Tab\"\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (isFocused && !isEditing) {\r\n        if (event.key === \"F2\" || event.key === \"Enter\") {\r\n          event.preventDefault();\r\n          event.stopPropagation();\r\n          meta?.onCellEditingStart?.(rowIndex, columnId);\r\n          return;\r\n        }\r\n\r\n        if (event.key === \" \") {\r\n          event.preventDefault();\r\n          event.stopPropagation();\r\n          meta?.onCellEditingStart?.(rowIndex, columnId);\r\n          return;\r\n        }\r\n\r\n        if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\r\n          event.preventDefault();\r\n          event.stopPropagation();\r\n          meta?.onCellEditingStart?.(rowIndex, columnId);\r\n        }\r\n      }\r\n    },\r\n    [onKeyDownProp, isFocused, isEditing, meta, rowIndex, columnId],\r\n  );\r\n\r\n  const rowHeight = meta?.rowHeight ?? \"short\";\r\n\r\n  return (\r\n    <div\r\n      role=\"button\"\r\n      data-slot=\"grid-cell-wrapper\"\r\n      data-editing={isEditing ? \"\" : undefined}\r\n      data-focused={isFocused ? \"\" : undefined}\r\n      data-selected={isSelected ? \"\" : undefined}\r\n      tabIndex={isFocused && !isEditing ? 0 : -1}\r\n      className={cn(\r\n        \"size-full px-2 py-1.5 text-left text-sm outline-none has-[[data-slot=checkbox]]:pt-2.5\",\r\n        {\r\n          \"ring-1 ring-ring ring-inset\": isFocused,\r\n          \"bg-yellow-100 dark:bg-yellow-900/30\":\r\n            isSearchMatch && !isActiveSearchMatch,\r\n          \"bg-orange-200 dark:bg-orange-900/50\": isActiveSearchMatch,\r\n          \"bg-primary/10\": isSelected && !isEditing,\r\n          \"cursor-default\": !isEditing,\r\n          \"[&_[data-slot=grid-cell-content]]:line-clamp-1\":\r\n            !isEditing && rowHeight === \"short\",\r\n          \"[&_[data-slot=grid-cell-content]]:line-clamp-2\":\r\n            !isEditing && rowHeight === \"medium\",\r\n          \"[&_[data-slot=grid-cell-content]]:line-clamp-3\":\r\n            !isEditing && rowHeight === \"tall\",\r\n          \"[&_[data-slot=grid-cell-content]]:line-clamp-4\":\r\n            !isEditing && rowHeight === \"extra-tall\",\r\n        },\r\n        className,\r\n      )}\r\n      onClick={onClick}\r\n      onContextMenu={onContextMenu}\r\n      onDoubleClick={onDoubleClick}\r\n      onMouseDown={onMouseDown}\r\n      onMouseEnter={onMouseEnter}\r\n      onMouseUp={onMouseUp}\r\n      onKeyDown={onKeyDown}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-cell-wrapper.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-cell-variants.tsx",
      "content": "\"use client\";\r\n\r\nimport type { Cell, Table } from \"@tanstack/react-table\";\r\nimport { Check, X } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { DataGridCellWrapper } from \"@/components/data-grid/data-grid-cell-wrapper\";\r\nimport { Badge } from \"@/components/ui/badge\";\r\nimport { Calendar } from \"@/components/ui/calendar\";\r\nimport { Checkbox } from \"@/components/ui/checkbox\";\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n  CommandSeparator,\r\n} from \"@/components/ui/command\";\r\nimport {\r\n  Popover,\r\n  PopoverAnchor,\r\n  PopoverContent,\r\n} from \"@/components/ui/popover\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from \"@/components/ui/select\";\r\nimport { Textarea } from \"@/components/ui/textarea\";\r\nimport { useDebouncedCallback } from \"@/hooks/use-debounced-callback\";\r\nimport { getLineCount } from \"@/lib/data-grid\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface CellVariantProps<TData> {\r\n  cell: Cell<TData, unknown>;\r\n  table: Table<TData>;\r\n  rowIndex: number;\r\n  columnId: string;\r\n  isEditing: boolean;\r\n  isFocused: boolean;\r\n  isSelected: boolean;\r\n}\r\n\r\nexport function ShortTextCell<TData>({\r\n  cell,\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isEditing,\r\n  isFocused,\r\n  isSelected,\r\n}: CellVariantProps<TData>) {\r\n  const initialValue = cell.getValue() as string;\r\n  const [value, setValue] = React.useState(initialValue);\r\n  const cellRef = React.useRef<HTMLDivElement>(null);\r\n  const containerRef = React.useRef<HTMLDivElement>(null);\r\n  const meta = table.options.meta;\r\n\r\n  const onBlur = React.useCallback(() => {\r\n    // Read the current value directly from the DOM to avoid stale state\r\n    const currentValue = cellRef.current?.textContent ?? \"\";\r\n    if (currentValue !== initialValue) {\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\r\n    }\r\n    meta?.onCellEditingStop?.();\r\n  }, [meta, rowIndex, columnId, initialValue]);\r\n\r\n  const onInput = React.useCallback(\r\n    (event: React.FormEvent<HTMLDivElement>) => {\r\n      const currentValue = event.currentTarget.textContent ?? \"\";\r\n      setValue(currentValue);\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onWrapperKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (isEditing) {\r\n        if (event.key === \"Enter\") {\r\n          event.preventDefault();\r\n          const currentValue = cellRef.current?.textContent ?? \"\";\r\n          if (currentValue !== initialValue) {\r\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\r\n          }\r\n          meta?.onCellEditingStop?.({ moveToNextRow: true });\r\n        } else if (event.key === \"Tab\") {\r\n          event.preventDefault();\r\n          const currentValue = cellRef.current?.textContent ?? \"\";\r\n          if (currentValue !== initialValue) {\r\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\r\n          }\r\n          meta?.onCellEditingStop?.({\r\n            direction: event.shiftKey ? \"left\" : \"right\",\r\n          });\r\n        } else if (event.key === \"Escape\") {\r\n          event.preventDefault();\r\n          setValue(initialValue);\r\n          cellRef.current?.blur();\r\n        }\r\n      } else if (\r\n        isFocused &&\r\n        event.key.length === 1 &&\r\n        !event.ctrlKey &&\r\n        !event.metaKey\r\n      ) {\r\n        // Handle typing to pre-fill the value when editing starts\r\n        setValue(event.key);\r\n\r\n        queueMicrotask(() => {\r\n          if (cellRef.current && cellRef.current.contentEditable === \"true\") {\r\n            cellRef.current.textContent = event.key;\r\n            const range = document.createRange();\r\n            const selection = window.getSelection();\r\n            range.selectNodeContents(cellRef.current);\r\n            range.collapse(false);\r\n            selection?.removeAllRanges();\r\n            selection?.addRange(range);\r\n          }\r\n        });\r\n      }\r\n    },\r\n    [isEditing, isFocused, initialValue, meta, rowIndex, columnId],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    setValue(initialValue);\r\n    if (cellRef.current && !isEditing) {\r\n      cellRef.current.textContent = initialValue;\r\n    }\r\n  }, [initialValue, isEditing]);\r\n\r\n  React.useEffect(() => {\r\n    if (isEditing && cellRef.current) {\r\n      cellRef.current.focus();\r\n\r\n      if (!cellRef.current.textContent && value) {\r\n        cellRef.current.textContent = value;\r\n      }\r\n\r\n      if (cellRef.current.textContent) {\r\n        const range = document.createRange();\r\n        const selection = window.getSelection();\r\n        range.selectNodeContents(cellRef.current);\r\n        range.collapse(false);\r\n        selection?.removeAllRanges();\r\n        selection?.addRange(range);\r\n      }\r\n    }\r\n    // Don't focus if we're in the middle of a scroll operation\r\n    if (\r\n      isFocused &&\r\n      !isEditing &&\r\n      !meta?.searchOpen &&\r\n      !meta?.isScrolling &&\r\n      containerRef.current\r\n    ) {\r\n      containerRef.current.focus();\r\n    }\r\n  }, [isFocused, isEditing, value, meta?.searchOpen, meta?.isScrolling]);\r\n\r\n  const displayValue = !isEditing ? (value ?? \"\") : \"\";\r\n\r\n  return (\r\n    <DataGridCellWrapper\r\n      ref={containerRef}\r\n      cell={cell}\r\n      table={table}\r\n      rowIndex={rowIndex}\r\n      columnId={columnId}\r\n      isEditing={isEditing}\r\n      isFocused={isFocused}\r\n      isSelected={isSelected}\r\n      onKeyDown={onWrapperKeyDown}\r\n    >\r\n      <div\r\n        role=\"textbox\"\r\n        data-slot=\"grid-cell-content\"\r\n        contentEditable={isEditing}\r\n        tabIndex={-1}\r\n        ref={cellRef}\r\n        onBlur={onBlur}\r\n        onInput={onInput}\r\n        suppressContentEditableWarning\r\n        className={cn(\"size-full overflow-hidden outline-none\", {\r\n          \"whitespace-nowrap [&_*]:inline [&_*]:whitespace-nowrap [&_br]:hidden\":\r\n            isEditing,\r\n        })}\r\n      >\r\n        {displayValue}\r\n      </div>\r\n    </DataGridCellWrapper>\r\n  );\r\n}\r\n\r\nexport function LongTextCell<TData>({\r\n  cell,\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isFocused,\r\n  isEditing,\r\n  isSelected,\r\n}: CellVariantProps<TData>) {\r\n  const initialValue = cell.getValue() as string;\r\n  const [value, setValue] = React.useState(initialValue ?? \"\");\r\n  const [open, setOpen] = React.useState(false);\r\n  const textareaRef = React.useRef<HTMLTextAreaElement>(null);\r\n  const containerRef = React.useRef<HTMLDivElement>(null);\r\n  const meta = table.options.meta;\r\n  const sideOffset = -(containerRef.current?.clientHeight ?? 0);\r\n\r\n  const prevInitialValueRef = React.useRef(initialValue);\r\n  if (initialValue !== prevInitialValueRef.current) {\r\n    prevInitialValueRef.current = initialValue;\r\n    setValue(initialValue ?? \"\");\r\n  }\r\n\r\n  // Debounced auto-save (300ms delay)\r\n  const debouncedSave = useDebouncedCallback((newValue: string) => {\r\n    meta?.onDataUpdate?.({ rowIndex, columnId, value: newValue });\r\n  }, 300);\r\n\r\n  const onSave = React.useCallback(() => {\r\n    // Immediately save any pending changes and close the popover\r\n    if (value !== initialValue) {\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value });\r\n    }\r\n    setOpen(false);\r\n    meta?.onCellEditingStop?.();\r\n  }, [meta, value, initialValue, rowIndex, columnId]);\r\n\r\n  const onCancel = React.useCallback(() => {\r\n    // Restore the original value\r\n    setValue(initialValue ?? \"\");\r\n    meta?.onDataUpdate?.({ rowIndex, columnId, value: initialValue });\r\n    setOpen(false);\r\n    meta?.onCellEditingStop?.();\r\n  }, [meta, initialValue, rowIndex, columnId]);\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n      const newValue = event.target.value;\r\n      setValue(newValue);\r\n      // Debounced auto-save\r\n      debouncedSave(newValue);\r\n    },\r\n    [debouncedSave],\r\n  );\r\n\r\n  const onOpenChange = React.useCallback(\r\n    (isOpen: boolean) => {\r\n      setOpen(isOpen);\r\n      if (!isOpen) {\r\n        // Immediately save any pending changes when closing\r\n        if (value !== initialValue) {\r\n          meta?.onDataUpdate?.({ rowIndex, columnId, value });\r\n        }\r\n        meta?.onCellEditingStop?.();\r\n      }\r\n    },\r\n    [meta, value, initialValue, rowIndex, columnId],\r\n  );\r\n\r\n  const onOpenAutoFocus: NonNullable<\r\n    React.ComponentProps<typeof PopoverContent>[\"onOpenAutoFocus\"]\r\n  > = React.useCallback((event) => {\r\n    event.preventDefault();\r\n    if (textareaRef.current) {\r\n      textareaRef.current.focus();\r\n      const length = textareaRef.current.value.length;\r\n      textareaRef.current.setSelectionRange(length, length);\r\n    }\r\n  }, []);\r\n\r\n  const onWrapperKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (isEditing && !open) {\r\n        if (event.key === \"Escape\") {\r\n          event.preventDefault();\r\n          meta?.onCellEditingStop?.();\r\n        } else if (event.key === \"Tab\") {\r\n          event.preventDefault();\r\n          // Save any pending changes\r\n          if (value !== initialValue) {\r\n            meta?.onDataUpdate?.({ rowIndex, columnId, value });\r\n          }\r\n          meta?.onCellEditingStop?.({\r\n            direction: event.shiftKey ? \"left\" : \"right\",\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [isEditing, open, meta, value, initialValue, rowIndex, columnId],\r\n  );\r\n\r\n  const onTextareaKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLTextAreaElement>) => {\r\n      if (event.key === \"Escape\") {\r\n        event.preventDefault();\r\n        onCancel();\r\n      } else if (event.key === \"Enter\" && (event.ctrlKey || event.metaKey)) {\r\n        event.preventDefault();\r\n        onSave();\r\n      }\r\n      // Stop propagation to prevent grid navigation\r\n      event.stopPropagation();\r\n    },\r\n    [onCancel, onSave],\r\n  );\r\n\r\n  const onTextareaBlur = React.useCallback(() => {\r\n    // Immediately save any pending changes on blur\r\n    if (value !== initialValue) {\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value });\r\n    }\r\n    setOpen(false);\r\n    meta?.onCellEditingStop?.();\r\n  }, [meta, value, initialValue, rowIndex, columnId]);\r\n\r\n  React.useEffect(() => {\r\n    if (isEditing && !open) {\r\n      setOpen(true);\r\n    }\r\n    if (\r\n      isFocused &&\r\n      !isEditing &&\r\n      !meta?.searchOpen &&\r\n      !meta?.isScrolling &&\r\n      containerRef.current\r\n    ) {\r\n      containerRef.current.focus();\r\n    }\r\n  }, [isFocused, isEditing, open, meta?.searchOpen, meta?.isScrolling]);\r\n\r\n  return (\r\n    <Popover open={open} onOpenChange={onOpenChange}>\r\n      <PopoverAnchor asChild>\r\n        <DataGridCellWrapper\r\n          ref={containerRef}\r\n          cell={cell}\r\n          table={table}\r\n          rowIndex={rowIndex}\r\n          columnId={columnId}\r\n          isEditing={isEditing}\r\n          isFocused={isFocused}\r\n          isSelected={isSelected}\r\n          onKeyDown={onWrapperKeyDown}\r\n        >\r\n          <span data-slot=\"grid-cell-content\">{value}</span>\r\n        </DataGridCellWrapper>\r\n      </PopoverAnchor>\r\n      <PopoverContent\r\n        data-grid-cell-editor=\"\"\r\n        align=\"start\"\r\n        side=\"bottom\"\r\n        sideOffset={sideOffset}\r\n        className=\"w-[400px] rounded-none p-0\"\r\n        onOpenAutoFocus={onOpenAutoFocus}\r\n      >\r\n        <Textarea\r\n          ref={textareaRef}\r\n          value={value}\r\n          onChange={onChange}\r\n          onKeyDown={onTextareaKeyDown}\r\n          onBlur={onTextareaBlur}\r\n          className=\"min-h-[150px] resize-none rounded-none border-0 shadow-none focus-visible:ring-0\"\r\n          placeholder=\"Enter text...\"\r\n        />\r\n      </PopoverContent>\r\n    </Popover>\r\n  );\r\n}\r\n\r\nexport function NumberCell<TData>({\r\n  cell,\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isFocused,\r\n  isEditing,\r\n  isSelected,\r\n}: CellVariantProps<TData>) {\r\n  const initialValue = cell.getValue() as number;\r\n  const [value, setValue] = React.useState(String(initialValue ?? \"\"));\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n  const containerRef = React.useRef<HTMLDivElement>(null);\r\n  const meta = table.options.meta;\r\n  const cellOpts = cell.column.columnDef.meta?.cell;\r\n  const min = cellOpts?.variant === \"number\" ? cellOpts.min : undefined;\r\n  const max = cellOpts?.variant === \"number\" ? cellOpts.max : undefined;\r\n  const step = cellOpts?.variant === \"number\" ? cellOpts.step : undefined;\r\n\r\n  const onBlur = React.useCallback(() => {\r\n    const numValue = value === \"\" ? null : Number(value);\r\n    if (numValue !== initialValue) {\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\r\n    }\r\n    meta?.onCellEditingStop?.();\r\n  }, [meta, rowIndex, columnId, initialValue, value]);\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<HTMLInputElement>) => {\r\n      setValue(event.target.value);\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onWrapperKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (isEditing) {\r\n        if (event.key === \"Enter\") {\r\n          event.preventDefault();\r\n          const numValue = value === \"\" ? null : Number(value);\r\n          if (numValue !== initialValue) {\r\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\r\n          }\r\n          meta?.onCellEditingStop?.({ moveToNextRow: true });\r\n        } else if (event.key === \"Tab\") {\r\n          event.preventDefault();\r\n          const numValue = value === \"\" ? null : Number(value);\r\n          if (numValue !== initialValue) {\r\n            meta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\r\n          }\r\n          meta?.onCellEditingStop?.({\r\n            direction: event.shiftKey ? \"left\" : \"right\",\r\n          });\r\n        } else if (event.key === \"Escape\") {\r\n          event.preventDefault();\r\n          setValue(String(initialValue ?? \"\"));\r\n          inputRef.current?.blur();\r\n        }\r\n      } else if (isFocused) {\r\n        // Handle Backspace to start editing with empty value\r\n        if (event.key === \"Backspace\") {\r\n          setValue(\"\");\r\n        } else if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\r\n          // Handle typing to pre-fill the value when editing starts\r\n          setValue(event.key);\r\n        }\r\n      }\r\n    },\r\n    [isEditing, isFocused, initialValue, meta, rowIndex, columnId, value],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    setValue(String(initialValue ?? \"\"));\r\n  }, [initialValue]);\r\n\r\n  React.useEffect(() => {\r\n    if (isEditing && inputRef.current) {\r\n      inputRef.current.focus();\r\n      inputRef.current.select();\r\n    }\r\n    if (\r\n      isFocused &&\r\n      !isEditing &&\r\n      !meta?.searchOpen &&\r\n      !meta?.isScrolling &&\r\n      containerRef.current\r\n    ) {\r\n      containerRef.current.focus();\r\n    }\r\n  }, [isFocused, isEditing, meta?.searchOpen, meta?.isScrolling]);\r\n\r\n  return (\r\n    <DataGridCellWrapper\r\n      ref={containerRef}\r\n      cell={cell}\r\n      table={table}\r\n      rowIndex={rowIndex}\r\n      columnId={columnId}\r\n      isEditing={isEditing}\r\n      isFocused={isFocused}\r\n      isSelected={isSelected}\r\n      onKeyDown={onWrapperKeyDown}\r\n    >\r\n      {isEditing ? (\r\n        <input\r\n          ref={inputRef}\r\n          type=\"number\"\r\n          value={value}\r\n          min={min}\r\n          max={max}\r\n          step={step}\r\n          onBlur={onBlur}\r\n          onChange={onChange}\r\n          className=\"w-full border-none bg-transparent p-0 outline-none\"\r\n        />\r\n      ) : (\r\n        <span data-slot=\"grid-cell-content\">{value}</span>\r\n      )}\r\n    </DataGridCellWrapper>\r\n  );\r\n}\r\n\r\nexport function SelectCell<TData>({\r\n  cell,\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isFocused,\r\n  isEditing,\r\n  isSelected,\r\n}: CellVariantProps<TData>) {\r\n  const initialValue = cell.getValue() as string;\r\n  const [value, setValue] = React.useState(initialValue);\r\n  const [open, setOpen] = React.useState(false);\r\n  const containerRef = React.useRef<HTMLDivElement>(null);\r\n  const meta = table.options.meta;\r\n  const cellOpts = cell.column.columnDef.meta?.cell;\r\n  const options = cellOpts?.variant === \"select\" ? cellOpts.options : [];\r\n\r\n  const onValueChange = React.useCallback(\r\n    (newValue: string) => {\r\n      setValue(newValue);\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: newValue });\r\n      meta?.onCellEditingStop?.();\r\n    },\r\n    [meta, rowIndex, columnId],\r\n  );\r\n\r\n  const onOpenChange = React.useCallback(\r\n    (isOpen: boolean) => {\r\n      setOpen(isOpen);\r\n      if (!isOpen) {\r\n        meta?.onCellEditingStop?.();\r\n      }\r\n    },\r\n    [meta],\r\n  );\r\n\r\n  const onWrapperKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (isEditing) {\r\n        if (event.key === \"Escape\") {\r\n          event.preventDefault();\r\n          setValue(initialValue);\r\n          setOpen(false);\r\n          meta?.onCellEditingStop?.();\r\n        } else if (event.key === \"Tab\") {\r\n          event.preventDefault();\r\n          setOpen(false);\r\n          meta?.onCellEditingStop?.({\r\n            direction: event.shiftKey ? \"left\" : \"right\",\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [isEditing, initialValue, meta],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    setValue(initialValue);\r\n  }, [initialValue]);\r\n\r\n  React.useEffect(() => {\r\n    if (isEditing && !open) {\r\n      setOpen(true);\r\n    }\r\n    if (\r\n      isFocused &&\r\n      !isEditing &&\r\n      !meta?.searchOpen &&\r\n      !meta?.isScrolling &&\r\n      containerRef.current\r\n    ) {\r\n      containerRef.current.focus();\r\n    }\r\n  }, [isFocused, isEditing, open, meta?.searchOpen, meta?.isScrolling]);\r\n\r\n  const displayLabel =\r\n    options.find((opt) => opt.value === value)?.label ?? value;\r\n\r\n  return (\r\n    <DataGridCellWrapper\r\n      ref={containerRef}\r\n      cell={cell}\r\n      table={table}\r\n      rowIndex={rowIndex}\r\n      columnId={columnId}\r\n      isEditing={isEditing}\r\n      isFocused={isFocused}\r\n      isSelected={isSelected}\r\n      onKeyDown={onWrapperKeyDown}\r\n    >\r\n      {isEditing ? (\r\n        <Select\r\n          value={value}\r\n          onValueChange={onValueChange}\r\n          open={open}\r\n          onOpenChange={onOpenChange}\r\n        >\r\n          <SelectTrigger\r\n            size=\"sm\"\r\n            className=\"size-full items-start border-none p-0 shadow-none focus-visible:ring-0 dark:bg-transparent [&_svg]:hidden\"\r\n          >\r\n            <SelectValue />\r\n          </SelectTrigger>\r\n          <SelectContent\r\n            data-grid-cell-editor=\"\"\r\n            // compensate for the wrapper padding\r\n            align=\"start\"\r\n            alignOffset={-8}\r\n            sideOffset={-8}\r\n            className=\"min-w-[calc(var(--radix-select-trigger-width)+16px)]\"\r\n          >\r\n            {options.map((option) => (\r\n              <SelectItem key={option.value} value={option.value}>\r\n                {option.label}\r\n              </SelectItem>\r\n            ))}\r\n          </SelectContent>\r\n        </Select>\r\n      ) : (\r\n        <span data-slot=\"grid-cell-content\">{displayLabel}</span>\r\n      )}\r\n    </DataGridCellWrapper>\r\n  );\r\n}\r\n\r\nexport function MultiSelectCell<TData>({\r\n  cell,\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isFocused,\r\n  isEditing,\r\n  isSelected,\r\n}: CellVariantProps<TData>) {\r\n  const cellValue = React.useMemo(\r\n    () => (cell.getValue() as string[]) ?? [],\r\n    [cell],\r\n  );\r\n\r\n  const cellId = `${rowIndex}-${columnId}`;\r\n  const prevCellIdRef = React.useRef(cellId);\r\n\r\n  const [selectedValues, setSelectedValues] =\r\n    React.useState<string[]>(cellValue);\r\n  const [open, setOpen] = React.useState(false);\r\n  const [searchValue, setSearchValue] = React.useState(\"\");\r\n  const containerRef = React.useRef<HTMLDivElement>(null);\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n  const meta = table.options.meta;\r\n  const cellOpts = cell.column.columnDef.meta?.cell;\r\n  const options = cellOpts?.variant === \"multi-select\" ? cellOpts.options : [];\r\n  const sideOffset = -(containerRef.current?.clientHeight ?? 0);\r\n\r\n  if (prevCellIdRef.current !== cellId) {\r\n    prevCellIdRef.current = cellId;\r\n    setSelectedValues(cellValue);\r\n    setOpen(false);\r\n    setSearchValue(\"\");\r\n  }\r\n\r\n  const onValueChange = React.useCallback(\r\n    (value: string) => {\r\n      const newValues = selectedValues.includes(value)\r\n        ? selectedValues.filter((v) => v !== value)\r\n        : [...selectedValues, value];\r\n\r\n      setSelectedValues(newValues);\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: newValues });\r\n      // Clear search input and focus back on input after selection\r\n      setSearchValue(\"\");\r\n      queueMicrotask(() => inputRef.current?.focus());\r\n    },\r\n    [selectedValues, meta, rowIndex, columnId],\r\n  );\r\n\r\n  const removeValue = React.useCallback(\r\n    (valueToRemove: string, event?: React.MouseEvent) => {\r\n      event?.stopPropagation();\r\n      event?.preventDefault();\r\n      const newValues = selectedValues.filter((v) => v !== valueToRemove);\r\n      setSelectedValues(newValues);\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: newValues });\r\n      // Focus back on input after removing\r\n      setTimeout(() => inputRef.current?.focus(), 0);\r\n    },\r\n    [selectedValues, meta, rowIndex, columnId],\r\n  );\r\n\r\n  const clearAll = React.useCallback(() => {\r\n    setSelectedValues([]);\r\n    meta?.onDataUpdate?.({ rowIndex, columnId, value: [] });\r\n    queueMicrotask(() => inputRef.current?.focus());\r\n  }, [meta, rowIndex, columnId]);\r\n\r\n  const onOpenChange = React.useCallback(\r\n    (isOpen: boolean) => {\r\n      setOpen(isOpen);\r\n      if (!isOpen) {\r\n        setSearchValue(\"\");\r\n        meta?.onCellEditingStop?.();\r\n      }\r\n    },\r\n    [meta],\r\n  );\r\n\r\n  const onOpenAutoFocus: NonNullable<\r\n    React.ComponentProps<typeof PopoverContent>[\"onOpenAutoFocus\"]\r\n  > = React.useCallback((event) => {\r\n    event.preventDefault();\r\n    inputRef.current?.focus();\r\n  }, []);\r\n\r\n  const onWrapperKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (isEditing) {\r\n        if (event.key === \"Escape\") {\r\n          event.preventDefault();\r\n          setSelectedValues(cellValue);\r\n          setSearchValue(\"\");\r\n          setOpen(false);\r\n          meta?.onCellEditingStop?.();\r\n        } else if (event.key === \"Tab\") {\r\n          event.preventDefault();\r\n          setSearchValue(\"\");\r\n          setOpen(false);\r\n          meta?.onCellEditingStop?.({\r\n            direction: event.shiftKey ? \"left\" : \"right\",\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [isEditing, cellValue, meta],\r\n  );\r\n\r\n  const onInputKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLInputElement>) => {\r\n      // Handle backspace when input is empty - remove last selected item\r\n      if (\r\n        event.key === \"Backspace\" &&\r\n        searchValue === \"\" &&\r\n        selectedValues.length > 0\r\n      ) {\r\n        event.preventDefault();\r\n        const lastValue = selectedValues[selectedValues.length - 1];\r\n        if (lastValue) {\r\n          removeValue(lastValue);\r\n        }\r\n      }\r\n      // Prevent escape from propagating to close the popover immediately\r\n      // Let the command handle it first\r\n      if (event.key === \"Escape\") {\r\n        event.stopPropagation();\r\n      }\r\n    },\r\n    [searchValue, selectedValues, removeValue],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (isEditing && !open) {\r\n      setOpen(true);\r\n    }\r\n    if (\r\n      isFocused &&\r\n      !isEditing &&\r\n      !meta?.searchOpen &&\r\n      !meta?.isScrolling &&\r\n      containerRef.current\r\n    ) {\r\n      containerRef.current.focus();\r\n    }\r\n  }, [isFocused, isEditing, open, meta?.searchOpen, meta?.isScrolling]);\r\n\r\n  // Focus input when popover opens\r\n  React.useEffect(() => {\r\n    if (open && inputRef.current) {\r\n      setTimeout(() => inputRef.current?.focus(), 0);\r\n    }\r\n  }, [open]);\r\n\r\n  const displayLabels = selectedValues\r\n    .map((val) => options.find((opt) => opt.value === val)?.label ?? val)\r\n    .filter(Boolean);\r\n\r\n  const rowHeight = table.options.meta?.rowHeight ?? \"short\";\r\n\r\n  const lineCount = getLineCount(rowHeight);\r\n  const maxVisibleBadgeCount = lineCount * 3;\r\n\r\n  const visibleLabels = displayLabels.slice(0, maxVisibleBadgeCount);\r\n  const hiddenBadgeCount = Math.max(\r\n    0,\r\n    displayLabels.length - maxVisibleBadgeCount,\r\n  );\r\n\r\n  return (\r\n    <DataGridCellWrapper\r\n      ref={containerRef}\r\n      cell={cell}\r\n      table={table}\r\n      rowIndex={rowIndex}\r\n      columnId={columnId}\r\n      isEditing={isEditing}\r\n      isFocused={isFocused}\r\n      isSelected={isSelected}\r\n      onKeyDown={onWrapperKeyDown}\r\n    >\r\n      {isEditing ? (\r\n        <Popover open={open} onOpenChange={onOpenChange}>\r\n          <PopoverAnchor asChild>\r\n            <div className=\"absolute inset-0\" />\r\n          </PopoverAnchor>\r\n          <PopoverContent\r\n            data-grid-cell-editor=\"\"\r\n            align=\"start\"\r\n            sideOffset={sideOffset}\r\n            className=\"w-[300px] rounded-none p-0\"\r\n            onOpenAutoFocus={onOpenAutoFocus}\r\n          >\r\n            <Command className=\"[&_[data-slot=command-input-wrapper]]:h-auto [&_[data-slot=command-input-wrapper]]:border-none [&_[data-slot=command-input-wrapper]]:p-0 [&_[data-slot=command-input-wrapper]_svg]:hidden\">\r\n              <div className=\"flex min-h-9 flex-wrap items-center gap-1 border-b px-3 py-1.5\">\r\n                {selectedValues.map((value) => {\r\n                  const option = options.find((opt) => opt.value === value);\r\n                  const label = option?.label ?? value;\r\n\r\n                  return (\r\n                    <Badge\r\n                      key={value}\r\n                      variant=\"secondary\"\r\n                      className=\"h-5 gap-1 px-1.5 text-xs\"\r\n                    >\r\n                      {label}\r\n                      <button\r\n                        type=\"button\"\r\n                        onClick={(event) => removeValue(value, event)}\r\n                        onPointerDown={(event) => {\r\n                          event.preventDefault();\r\n                          event.stopPropagation();\r\n                        }}\r\n                      >\r\n                        <X className=\"size-3\" />\r\n                      </button>\r\n                    </Badge>\r\n                  );\r\n                })}\r\n                <CommandInput\r\n                  ref={inputRef}\r\n                  value={searchValue}\r\n                  onValueChange={setSearchValue}\r\n                  onKeyDown={onInputKeyDown}\r\n                  placeholder=\"Search...\"\r\n                  className=\"h-auto flex-1 p-0\"\r\n                />\r\n              </div>\r\n              <CommandList className=\"max-h-full\">\r\n                <CommandEmpty>No options found.</CommandEmpty>\r\n                <CommandGroup className=\"max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden\">\r\n                  {options.map((option) => {\r\n                    const isSelected = selectedValues.includes(option.value);\r\n\r\n                    return (\r\n                      <CommandItem\r\n                        key={option.value}\r\n                        value={option.label}\r\n                        onSelect={() => onValueChange(option.value)}\r\n                      >\r\n                        <div\r\n                          className={cn(\r\n                            \"flex size-4 items-center justify-center rounded-sm border border-primary\",\r\n                            isSelected\r\n                              ? \"bg-primary text-primary-foreground\"\r\n                              : \"opacity-50 [&_svg]:invisible\",\r\n                          )}\r\n                        >\r\n                          <Check className=\"size-3\" />\r\n                        </div>\r\n                        <span>{option.label}</span>\r\n                      </CommandItem>\r\n                    );\r\n                  })}\r\n                </CommandGroup>\r\n                {selectedValues.length > 0 && (\r\n                  <>\r\n                    <CommandSeparator />\r\n                    <CommandGroup>\r\n                      <CommandItem\r\n                        onSelect={clearAll}\r\n                        className=\"justify-center text-muted-foreground\"\r\n                      >\r\n                        Clear all\r\n                      </CommandItem>\r\n                    </CommandGroup>\r\n                  </>\r\n                )}\r\n              </CommandList>\r\n            </Command>\r\n          </PopoverContent>\r\n        </Popover>\r\n      ) : null}\r\n      {displayLabels.length > 0 ? (\r\n        <div className=\"flex flex-wrap items-center gap-1 overflow-hidden\">\r\n          {visibleLabels.map((label, index) => (\r\n            <Badge\r\n              key={selectedValues[index]}\r\n              variant=\"secondary\"\r\n              className=\"h-5 shrink-0 px-1.5 text-xs\"\r\n            >\r\n              {label}\r\n            </Badge>\r\n          ))}\r\n          {hiddenBadgeCount > 0 && (\r\n            <Badge\r\n              variant=\"outline\"\r\n              className=\"h-5 shrink-0 px-1.5 text-muted-foreground text-xs\"\r\n            >\r\n              +{hiddenBadgeCount}\r\n            </Badge>\r\n          )}\r\n        </div>\r\n      ) : null}\r\n    </DataGridCellWrapper>\r\n  );\r\n}\r\n\r\nexport function CheckboxCell<TData>({\r\n  cell,\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isFocused,\r\n  isSelected,\r\n}: CellVariantProps<TData>) {\r\n  const initialValue = cell.getValue() as boolean;\r\n  const [value, setValue] = React.useState(Boolean(initialValue));\r\n  const containerRef = React.useRef<HTMLDivElement>(null);\r\n  const meta = table.options.meta;\r\n\r\n  const onCheckedChange = React.useCallback(\r\n    (checked: boolean) => {\r\n      setValue(checked);\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: checked });\r\n    },\r\n    [meta, rowIndex, columnId],\r\n  );\r\n\r\n  const onWrapperKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (isFocused && (event.key === \" \" || event.key === \"Enter\")) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        onCheckedChange(!value);\r\n      }\r\n    },\r\n    [isFocused, value, onCheckedChange],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    setValue(Boolean(initialValue));\r\n  }, [initialValue]);\r\n\r\n  React.useEffect(() => {\r\n    if (\r\n      isFocused &&\r\n      !meta?.searchOpen &&\r\n      !meta?.isScrolling &&\r\n      containerRef.current\r\n    ) {\r\n      containerRef.current.focus();\r\n    }\r\n  }, [isFocused, meta?.searchOpen, meta?.isScrolling]);\r\n\r\n  const onWrapperClick = React.useCallback(\r\n    (event: React.MouseEvent) => {\r\n      if (isFocused) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        onCheckedChange(!value);\r\n      }\r\n    },\r\n    [isFocused, value, onCheckedChange],\r\n  );\r\n\r\n  const onCheckboxClick = React.useCallback((event: React.MouseEvent) => {\r\n    event.stopPropagation();\r\n  }, []);\r\n\r\n  const onCheckboxMouseDown = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      event.stopPropagation();\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onCheckboxDoubleClick = React.useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => {\r\n      event.stopPropagation();\r\n    },\r\n    [],\r\n  );\r\n\r\n  return (\r\n    <DataGridCellWrapper\r\n      ref={containerRef}\r\n      cell={cell}\r\n      table={table}\r\n      rowIndex={rowIndex}\r\n      columnId={columnId}\r\n      isEditing={false}\r\n      isFocused={isFocused}\r\n      isSelected={isSelected}\r\n      onClick={onWrapperClick}\r\n      onKeyDown={onWrapperKeyDown}\r\n      className=\"flex size-full justify-center\"\r\n    >\r\n      <Checkbox\r\n        checked={value}\r\n        onCheckedChange={onCheckedChange}\r\n        onClick={onCheckboxClick}\r\n        onMouseDown={onCheckboxMouseDown}\r\n        onDoubleClick={onCheckboxDoubleClick}\r\n        className=\"border-primary\"\r\n      />\r\n    </DataGridCellWrapper>\r\n  );\r\n}\r\n\r\nfunction formatDateForDisplay(dateStr: string) {\r\n  if (!dateStr) return \"\";\r\n  const date = new Date(dateStr);\r\n  return date.toLocaleDateString();\r\n}\r\n\r\nexport function DateCell<TData>({\r\n  cell,\r\n  table,\r\n  rowIndex,\r\n  columnId,\r\n  isFocused,\r\n  isEditing,\r\n  isSelected,\r\n}: CellVariantProps<TData>) {\r\n  const initialValue = cell.getValue() as string;\r\n  const [value, setValue] = React.useState(initialValue ?? \"\");\r\n  const [open, setOpen] = React.useState(false);\r\n  const containerRef = React.useRef<HTMLDivElement>(null);\r\n  const meta = table.options.meta;\r\n\r\n  const prevInitialValueRef = React.useRef(initialValue);\r\n  if (initialValue !== prevInitialValueRef.current) {\r\n    prevInitialValueRef.current = initialValue;\r\n    setValue(initialValue ?? \"\");\r\n  }\r\n\r\n  const selectedDate = value ? new Date(value) : undefined;\r\n\r\n  const onDateSelect = React.useCallback(\r\n    (date: Date | undefined) => {\r\n      if (!date) return;\r\n\r\n      const formattedDate = date.toISOString().split(\"T\")[0] ?? \"\";\r\n      setValue(formattedDate);\r\n      meta?.onDataUpdate?.({ rowIndex, columnId, value: formattedDate });\r\n      setOpen(false);\r\n      meta?.onCellEditingStop?.();\r\n    },\r\n    [meta, rowIndex, columnId],\r\n  );\r\n\r\n  const onOpenChange = React.useCallback(\r\n    (isOpen: boolean) => {\r\n      setOpen(isOpen);\r\n      if (!isOpen && isEditing) {\r\n        meta?.onCellEditingStop?.();\r\n      }\r\n    },\r\n    [isEditing, meta],\r\n  );\r\n\r\n  const onWrapperKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n      if (isEditing) {\r\n        if (event.key === \"Escape\") {\r\n          event.preventDefault();\r\n          setValue(initialValue);\r\n          setOpen(false);\r\n        } else if (event.key === \"Tab\") {\r\n          event.preventDefault();\r\n          setOpen(false);\r\n          meta?.onCellEditingStop?.({\r\n            direction: event.shiftKey ? \"left\" : \"right\",\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [isEditing, initialValue, meta],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (isEditing) {\r\n      setOpen(true);\r\n    } else {\r\n      setOpen(false);\r\n    }\r\n  }, [isEditing]);\r\n\r\n  React.useEffect(() => {\r\n    if (\r\n      isFocused &&\r\n      !isEditing &&\r\n      !meta?.searchOpen &&\r\n      !meta?.isScrolling &&\r\n      containerRef.current\r\n    ) {\r\n      containerRef.current.focus();\r\n    }\r\n  }, [isFocused, isEditing, meta?.searchOpen, meta?.isScrolling]);\r\n\r\n  return (\r\n    <DataGridCellWrapper\r\n      ref={containerRef}\r\n      cell={cell}\r\n      table={table}\r\n      rowIndex={rowIndex}\r\n      columnId={columnId}\r\n      isEditing={isEditing}\r\n      isFocused={isFocused}\r\n      isSelected={isSelected}\r\n      onKeyDown={onWrapperKeyDown}\r\n    >\r\n      <Popover open={open} onOpenChange={onOpenChange}>\r\n        <PopoverAnchor asChild>\r\n          <span data-slot=\"grid-cell-content\">\r\n            {formatDateForDisplay(value)}\r\n          </span>\r\n        </PopoverAnchor>\r\n        {isEditing && (\r\n          <PopoverContent\r\n            data-grid-cell-editor=\"\"\r\n            align=\"start\"\r\n            sideOffset={10}\r\n            className=\"w-auto p-0\"\r\n          >\r\n            <Calendar\r\n              autoFocus\r\n              captionLayout=\"dropdown\"\r\n              mode=\"single\"\r\n              className=\"rounded-md border shadow-sm\"\r\n              defaultMonth={selectedDate ?? new Date()}\r\n              selected={selectedDate}\r\n              onSelect={onDateSelect}\r\n            />\r\n          </PopoverContent>\r\n        )}\r\n      </Popover>\r\n    </DataGridCellWrapper>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-cell-variants.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-column-header.tsx",
      "content": "\"use client\";\r\n\r\nimport type {\r\n  ColumnSort,\r\n  Header,\r\n  SortDirection,\r\n  SortingState,\r\n  Table,\r\n} from \"@tanstack/react-table\";\r\nimport {\r\n  BaselineIcon,\r\n  CalendarIcon,\r\n  CheckSquareIcon,\r\n  ChevronDownIcon,\r\n  ChevronUpIcon,\r\n  EyeOffIcon,\r\n  HashIcon,\r\n  ListChecksIcon,\r\n  ListIcon,\r\n  PinIcon,\r\n  PinOffIcon,\r\n  TextInitialIcon,\r\n  XIcon,\r\n} from \"lucide-react\";\r\nimport * as React from \"react\";\r\n\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuCheckboxItem,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuSeparator,\r\n  DropdownMenuTrigger,\r\n} from \"@/components/ui/dropdown-menu\";\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipTrigger,\r\n} from \"@/components/ui/tooltip\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport type { Cell } from \"@/types/data-grid\";\r\n\r\nfunction getColumnVariant(variant?: Cell[\"variant\"]): {\r\n  icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;\r\n  label: string;\r\n} | null {\r\n  switch (variant) {\r\n    case \"short-text\":\r\n      return { icon: BaselineIcon, label: \"Short text\" };\r\n    case \"long-text\":\r\n      return { icon: TextInitialIcon, label: \"Long text\" };\r\n    case \"number\":\r\n      return { icon: HashIcon, label: \"Number\" };\r\n    case \"select\":\r\n      return { icon: ListIcon, label: \"Select\" };\r\n    case \"multi-select\":\r\n      return { icon: ListChecksIcon, label: \"Multi-select\" };\r\n    case \"checkbox\":\r\n      return { icon: CheckSquareIcon, label: \"Checkbox\" };\r\n    case \"date\":\r\n      return { icon: CalendarIcon, label: \"Date\" };\r\n    default:\r\n      return null;\r\n  }\r\n}\r\n\r\ninterface DataGridColumnHeaderProps<TData, TValue>\r\n  extends React.ComponentProps<typeof DropdownMenuTrigger> {\r\n  header: Header<TData, TValue>;\r\n  table: Table<TData>;\r\n}\r\n\r\nexport function DataGridColumnHeader<TData, TValue>({\r\n  header,\r\n  table,\r\n  className,\r\n  onPointerDown,\r\n  ...props\r\n}: DataGridColumnHeaderProps<TData, TValue>) {\r\n  const column = header.column;\r\n  const label = column.columnDef.meta?.label\r\n    ? column.columnDef.meta.label\r\n    : typeof column.columnDef.header === \"string\"\r\n      ? column.columnDef.header\r\n      : column.id;\r\n\r\n  const isAnyColumnResizing =\r\n    table.getState().columnSizingInfo.isResizingColumn;\r\n\r\n  const cellVariant = column.columnDef.meta?.cell;\r\n  const columnVariant = getColumnVariant(cellVariant?.variant);\r\n\r\n  const pinnedPosition = column.getIsPinned();\r\n  const isPinnedLeft = pinnedPosition === \"left\";\r\n  const isPinnedRight = pinnedPosition === \"right\";\r\n\r\n  const onSortingChange = React.useCallback(\r\n    (direction: SortDirection) => {\r\n      table.setSorting((prev: SortingState) => {\r\n        const existingSortIndex = prev.findIndex(\r\n          (sort) => sort.id === column.id,\r\n        );\r\n        const newSort: ColumnSort = {\r\n          id: column.id,\r\n          desc: direction === \"desc\",\r\n        };\r\n\r\n        if (existingSortIndex >= 0) {\r\n          const updated = [...prev];\r\n          updated[existingSortIndex] = newSort;\r\n          return updated;\r\n        } else {\r\n          return [...prev, newSort];\r\n        }\r\n      });\r\n    },\r\n    [column.id, table],\r\n  );\r\n\r\n  const onSortRemove = React.useCallback(() => {\r\n    table.setSorting((prev: SortingState) =>\r\n      prev.filter((sort) => sort.id !== column.id),\r\n    );\r\n  }, [column.id, table]);\r\n\r\n  const onLeftPin = React.useCallback(() => {\r\n    column.pin(\"left\");\r\n  }, [column]);\r\n\r\n  const onRightPin = React.useCallback(() => {\r\n    column.pin(\"right\");\r\n  }, [column]);\r\n\r\n  const onUnpin = React.useCallback(() => {\r\n    column.pin(false);\r\n  }, [column]);\r\n\r\n  const onTriggerPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<HTMLButtonElement>) => {\r\n      onPointerDown?.(event);\r\n      if (event.defaultPrevented) return;\r\n\r\n      if (event.button !== 0) {\r\n        return;\r\n      }\r\n      table.options.meta?.onColumnClick?.(column.id);\r\n    },\r\n    [table.options.meta, column.id, onPointerDown],\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <DropdownMenu>\r\n        <DropdownMenuTrigger\r\n          className={cn(\r\n            \"flex size-full items-center justify-between gap-2 p-2 text-sm hover:bg-accent/40 data-[state=open]:bg-accent/40 [&_svg]:size-4\",\r\n            isAnyColumnResizing && \"pointer-events-none\",\r\n            className,\r\n          )}\r\n          onPointerDown={onTriggerPointerDown}\r\n          {...props}\r\n        >\r\n          <div className=\"flex min-w-0 flex-1 items-center gap-1.5\">\r\n            {columnVariant && (\r\n              <Tooltip delayDuration={100}>\r\n                <TooltipTrigger asChild>\r\n                  <columnVariant.icon className=\"size-3.5 shrink-0 text-muted-foreground\" />\r\n                </TooltipTrigger>\r\n                <TooltipContent side=\"top\">\r\n                  <p>{columnVariant.label}</p>\r\n                </TooltipContent>\r\n              </Tooltip>\r\n            )}\r\n            <span className=\"truncate\">{label}</span>\r\n          </div>\r\n          <ChevronDownIcon className=\"shrink-0 text-muted-foreground\" />\r\n        </DropdownMenuTrigger>\r\n        <DropdownMenuContent align=\"start\" sideOffset={0} className=\"w-60\">\r\n          {column.getCanSort() && (\r\n            <>\r\n              <DropdownMenuCheckboxItem\r\n                className=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\r\n                checked={column.getIsSorted() === \"asc\"}\r\n                onClick={() => onSortingChange(\"asc\")}\r\n              >\r\n                <ChevronUpIcon />\r\n                Sort asc\r\n              </DropdownMenuCheckboxItem>\r\n              <DropdownMenuCheckboxItem\r\n                className=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\r\n                checked={column.getIsSorted() === \"desc\"}\r\n                onClick={() => onSortingChange(\"desc\")}\r\n              >\r\n                <ChevronDownIcon />\r\n                Sort desc\r\n              </DropdownMenuCheckboxItem>\r\n              {column.getIsSorted() && (\r\n                <DropdownMenuItem onClick={onSortRemove}>\r\n                  <XIcon />\r\n                  Remove sort\r\n                </DropdownMenuItem>\r\n              )}\r\n            </>\r\n          )}\r\n          {column.getCanPin() && (\r\n            <>\r\n              {column.getCanSort() && <DropdownMenuSeparator />}\r\n\r\n              {isPinnedLeft ? (\r\n                <DropdownMenuItem\r\n                  className=\"[&_svg]:text-muted-foreground\"\r\n                  onClick={onUnpin}\r\n                >\r\n                  <PinOffIcon />\r\n                  Unpin from left\r\n                </DropdownMenuItem>\r\n              ) : (\r\n                <DropdownMenuItem\r\n                  className=\"[&_svg]:text-muted-foreground\"\r\n                  onClick={onLeftPin}\r\n                >\r\n                  <PinIcon />\r\n                  Pin to left\r\n                </DropdownMenuItem>\r\n              )}\r\n              {isPinnedRight ? (\r\n                <DropdownMenuItem\r\n                  className=\"[&_svg]:text-muted-foreground\"\r\n                  onClick={onUnpin}\r\n                >\r\n                  <PinOffIcon />\r\n                  Unpin from right\r\n                </DropdownMenuItem>\r\n              ) : (\r\n                <DropdownMenuItem\r\n                  className=\"[&_svg]:text-muted-foreground\"\r\n                  onClick={onRightPin}\r\n                >\r\n                  <PinIcon />\r\n                  Pin to right\r\n                </DropdownMenuItem>\r\n              )}\r\n            </>\r\n          )}\r\n          {column.getCanHide() && (\r\n            <>\r\n              <DropdownMenuSeparator />\r\n              <DropdownMenuCheckboxItem\r\n                className=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\r\n                checked={!column.getIsVisible()}\r\n                onClick={() => column.toggleVisibility(false)}\r\n              >\r\n                <EyeOffIcon />\r\n                Hide column\r\n              </DropdownMenuCheckboxItem>\r\n            </>\r\n          )}\r\n        </DropdownMenuContent>\r\n      </DropdownMenu>\r\n      {header.column.getCanResize() && (\r\n        <DataGridColumnResizer header={header} table={table} label={label} />\r\n      )}\r\n    </>\r\n  );\r\n}\r\n\r\nconst DataGridColumnResizer = React.memo(\r\n  DataGridColumnResizerImpl,\r\n  (prev, next) => {\r\n    const prevColumn = prev.header.column;\r\n    const nextColumn = next.header.column;\r\n\r\n    if (\r\n      prevColumn.getIsResizing() !== nextColumn.getIsResizing() ||\r\n      prevColumn.getSize() !== nextColumn.getSize()\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    if (prev.label !== next.label) return false;\r\n\r\n    return true;\r\n  },\r\n) as typeof DataGridColumnResizerImpl;\r\n\r\ninterface DataGridColumnResizerProps<TData, TValue>\r\n  extends DataGridColumnHeaderProps<TData, TValue> {\r\n  label: string;\r\n}\r\n\r\nfunction DataGridColumnResizerImpl<TData, TValue>({\r\n  header,\r\n  table,\r\n  label,\r\n}: DataGridColumnResizerProps<TData, TValue>) {\r\n  const defaultColumnDef = table._getDefaultColumnDef();\r\n\r\n  const onDoubleClick = React.useCallback(() => {\r\n    header.column.resetSize();\r\n  }, [header.column]);\r\n\r\n  return (\r\n    <div\r\n      role=\"separator\"\r\n      aria-orientation=\"vertical\"\r\n      aria-label={`Resize ${label} column`}\r\n      aria-valuenow={header.column.getSize()}\r\n      aria-valuemin={defaultColumnDef.minSize}\r\n      aria-valuemax={defaultColumnDef.maxSize}\r\n      tabIndex={0}\r\n      className={cn(\r\n        \"after:-translate-x-1/2 absolute top-0 right-[-1px] z-50 h-full w-0.5 cursor-ew-resize touch-none select-none bg-border transition-opacity after:absolute after:inset-y-0 after:left-1/2 after:h-full after:w-[18px] after:content-[''] hover:bg-primary focus:bg-primary focus:outline-none\",\r\n        header.column.getIsResizing()\r\n          ? \"bg-primary\"\r\n          : \"opacity-0 hover:opacity-100\",\r\n      )}\r\n      onDoubleClick={onDoubleClick}\r\n      onMouseDown={header.getResizeHandler()}\r\n      onTouchStart={header.getResizeHandler()}\r\n    />\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-column-header.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-context-menu.tsx",
      "content": "\"use client\";\r\n\r\nimport type { Table, TableMeta } from \"@tanstack/react-table\";\r\nimport { CopyIcon, EraserIcon } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { toast } from \"sonner\";\r\nimport {\r\n  DropdownMenu,\r\n  DropdownMenuContent,\r\n  DropdownMenuItem,\r\n  DropdownMenuTrigger,\r\n} from \"@/components/ui/dropdown-menu\";\r\nimport { parseCellKey } from \"@/lib/data-grid\";\r\nimport type { UpdateCell } from \"@/types/data-grid\";\r\n\r\ninterface DataGridContextMenuProps<TData> {\r\n  table: Table<TData>;\r\n}\r\n\r\nexport function DataGridContextMenu<TData>({\r\n  table,\r\n}: DataGridContextMenuProps<TData>) {\r\n  const meta = table.options.meta;\r\n  const contextMenu = meta?.contextMenu;\r\n  const onContextMenuOpenChange = meta?.onContextMenuOpenChange;\r\n  const selectionState = meta?.selectionState;\r\n  const dataGridRef = meta?.dataGridRef;\r\n  const onDataUpdate = meta?.onDataUpdate;\r\n\r\n  if (!contextMenu) return null;\r\n\r\n  return (\r\n    <ContextMenu\r\n      table={table}\r\n      dataGridRef={dataGridRef}\r\n      contextMenu={contextMenu}\r\n      onContextMenuOpenChange={onContextMenuOpenChange}\r\n      selectionState={selectionState}\r\n      onDataUpdate={onDataUpdate}\r\n    />\r\n  );\r\n}\r\n\r\ninterface ContextMenuProps<TData>\r\n  extends Pick<\r\n      TableMeta<TData>,\r\n      | \"dataGridRef\"\r\n      | \"onContextMenuOpenChange\"\r\n      | \"selectionState\"\r\n      | \"onDataUpdate\"\r\n    >,\r\n    Required<Pick<TableMeta<TData>, \"contextMenu\">> {\r\n  table: Table<TData>;\r\n}\r\n\r\nconst ContextMenu = React.memo(ContextMenuImpl, (prev, next) => {\r\n  if (prev.contextMenu.open !== next.contextMenu.open) return false;\r\n  if (!next.contextMenu.open) return true;\r\n  if (prev.contextMenu.x !== next.contextMenu.x) return false;\r\n  if (prev.contextMenu.y !== next.contextMenu.y) return false;\r\n\r\n  const prevSize = prev.selectionState?.selectedCells?.size ?? 0;\r\n  const nextSize = next.selectionState?.selectedCells?.size ?? 0;\r\n  if (prevSize !== nextSize) return false;\r\n\r\n  return true;\r\n}) as typeof ContextMenuImpl;\r\n\r\nfunction ContextMenuImpl<TData>({\r\n  table,\r\n  dataGridRef,\r\n  contextMenu,\r\n  onContextMenuOpenChange,\r\n  selectionState,\r\n  onDataUpdate,\r\n}: ContextMenuProps<TData>) {\r\n  const triggerStyle = React.useMemo<React.CSSProperties>(\r\n    () => ({\r\n      position: \"fixed\",\r\n      left: `${contextMenu.x}px`,\r\n      top: `${contextMenu.y}px`,\r\n      width: \"1px\",\r\n      height: \"1px\",\r\n      padding: 0,\r\n      margin: 0,\r\n      border: \"none\",\r\n      background: \"transparent\",\r\n      pointerEvents: \"none\",\r\n      opacity: 0,\r\n    }),\r\n    [contextMenu.x, contextMenu.y],\r\n  );\r\n\r\n  const onCloseAutoFocus: NonNullable<\r\n    React.ComponentProps<typeof DropdownMenuContent>[\"onCloseAutoFocus\"]\r\n  > = React.useCallback(\r\n    (event) => {\r\n      event.preventDefault();\r\n      dataGridRef?.current?.focus();\r\n    },\r\n    [dataGridRef],\r\n  );\r\n\r\n  const onCopy = React.useCallback(() => {\r\n    if (\r\n      !selectionState?.selectedCells ||\r\n      selectionState.selectedCells.size === 0\r\n    )\r\n      return;\r\n\r\n    const rows = table.getRowModel().rows;\r\n    const columnIds: string[] = [];\r\n\r\n    // Collect all unique column IDs from selected cells\r\n    const selectedCellsArray = Array.from(selectionState.selectedCells);\r\n    for (const cellKey of selectedCellsArray) {\r\n      const { columnId } = parseCellKey(cellKey);\r\n      if (columnId && !columnIds.includes(columnId)) {\r\n        columnIds.push(columnId);\r\n      }\r\n    }\r\n\r\n    // Build grid of selected cells\r\n    const cellData = new Map<string, string>();\r\n    for (const cellKey of selectedCellsArray) {\r\n      const { rowIndex, columnId } = parseCellKey(cellKey);\r\n      const row = rows[rowIndex];\r\n      if (row) {\r\n        const cell = row\r\n          .getVisibleCells()\r\n          .find((c) => c.column.id === columnId);\r\n        if (cell) {\r\n          const value = cell.getValue();\r\n          cellData.set(cellKey, String(value ?? \"\"));\r\n        }\r\n      }\r\n    }\r\n\r\n    // Get row indices and column indices\r\n    const rowIndices = new Set<number>();\r\n    const colIndices = new Set<number>();\r\n\r\n    for (const cellKey of selectedCellsArray) {\r\n      const { rowIndex, columnId } = parseCellKey(cellKey);\r\n      rowIndices.add(rowIndex);\r\n      const colIndex = columnIds.indexOf(columnId);\r\n      if (colIndex >= 0) {\r\n        colIndices.add(colIndex);\r\n      }\r\n    }\r\n\r\n    const sortedRowIndices = Array.from(rowIndices).sort((a, b) => a - b);\r\n    const sortedColIndices = Array.from(colIndices).sort((a, b) => a - b);\r\n    const sortedColumnIds = sortedColIndices.map((i) => columnIds[i]);\r\n\r\n    // Build TSV (tab-separated values)\r\n    const tsvData = sortedRowIndices\r\n      .map((rowIndex) =>\r\n        sortedColumnIds\r\n          .map((columnId) => {\r\n            const cellKey = `${rowIndex}:${columnId}`;\r\n            return cellData.get(cellKey) ?? \"\";\r\n          })\r\n          .join(\"\\t\"),\r\n      )\r\n      .join(\"\\n\");\r\n\r\n    navigator.clipboard.writeText(tsvData);\r\n    toast.success(\r\n      `${selectionState.selectedCells.size} cell${selectionState.selectedCells.size !== 1 ? \"s\" : \"\"} copied`,\r\n    );\r\n  }, [table, selectionState]);\r\n\r\n  const onClear = React.useCallback(() => {\r\n    if (\r\n      !selectionState?.selectedCells ||\r\n      selectionState.selectedCells.size === 0\r\n    )\r\n      return;\r\n\r\n    const updates: Array<UpdateCell> = [];\r\n\r\n    for (const cellKey of selectionState.selectedCells) {\r\n      const { rowIndex, columnId } = parseCellKey(cellKey);\r\n      updates.push({ rowIndex, columnId, value: \"\" });\r\n    }\r\n\r\n    onDataUpdate?.(updates);\r\n\r\n    toast.success(\r\n      `${updates.length} cell${updates.length !== 1 ? \"s\" : \"\"} cleared`,\r\n    );\r\n  }, [onDataUpdate, selectionState]);\r\n\r\n  return (\r\n    <DropdownMenu\r\n      open={contextMenu.open}\r\n      onOpenChange={onContextMenuOpenChange}\r\n    >\r\n      <DropdownMenuTrigger style={triggerStyle} />\r\n      <DropdownMenuContent\r\n        data-grid-popover=\"\"\r\n        align=\"start\"\r\n        className=\"w-48\"\r\n        onCloseAutoFocus={onCloseAutoFocus}\r\n      >\r\n        <DropdownMenuItem onSelect={onCopy}>\r\n          <CopyIcon />\r\n          Copy\r\n        </DropdownMenuItem>\r\n        <DropdownMenuItem onSelect={onClear}>\r\n          <EraserIcon />\r\n          Clear\r\n        </DropdownMenuItem>\r\n      </DropdownMenuContent>\r\n    </DropdownMenu>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-context-menu.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-keyboard-shortcuts.tsx",
      "content": "\"use client\";\r\n\r\nimport { SearchIcon, XIcon } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Dialog,\r\n  DialogClose,\r\n  DialogContent,\r\n  DialogDescription,\r\n  DialogHeader,\r\n  DialogTitle,\r\n} from \"@/components/ui/dialog\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { Kbd, KbdGroup } from \"@/components/ui/kbd\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\n\r\nconst SHORTCUT_KEY = \"/\";\r\n\r\ninterface ShortcutGroup {\r\n  title: string;\r\n  shortcuts: Array<{\r\n    keys: string[];\r\n    description: string;\r\n  }>;\r\n}\r\n\r\ninterface DataGridKeyboardShortcutsProps {\r\n  enableSearch?: boolean;\r\n}\r\n\r\nexport const DataGridKeyboardShortcuts = React.memo(\r\n  DataGridKeyboardShortcutsImpl,\r\n  (prev, next) => {\r\n    return prev.enableSearch === next.enableSearch;\r\n  },\r\n);\r\n\r\nfunction DataGridKeyboardShortcutsImpl({\r\n  enableSearch = false,\r\n}: DataGridKeyboardShortcutsProps) {\r\n  const [open, setOpen] = React.useState(false);\r\n  const [input, setInput] = React.useState(\"\");\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  const isMac =\r\n    typeof navigator !== \"undefined\"\r\n      ? /Mac|iPhone|iPad|iPod/.test(navigator.userAgent)\r\n      : false;\r\n\r\n  const modKey = isMac ? \"⌘\" : \"Ctrl\";\r\n\r\n  const onOpenChange = React.useCallback((isOpen: boolean) => {\r\n    setOpen(isOpen);\r\n    if (!isOpen) {\r\n      setInput(\"\");\r\n    }\r\n  }, []);\r\n\r\n  const onOpenAutoFocus = React.useCallback((event: Event) => {\r\n    event.preventDefault();\r\n    inputRef.current?.focus();\r\n  }, []);\r\n\r\n  const onInputChange = React.useCallback(\r\n    (event: React.ChangeEvent<HTMLInputElement>) => {\r\n      setInput(event.target.value);\r\n    },\r\n    [],\r\n  );\r\n\r\n  const shortcutGroups: ShortcutGroup[] = React.useMemo(\r\n    () => [\r\n      {\r\n        title: \"Navigation\",\r\n        shortcuts: [\r\n          {\r\n            keys: [\"↑\", \"↓\", \"←\", \"→\"],\r\n            description: \"Navigate between cells\",\r\n          },\r\n          {\r\n            keys: [\"Tab\"],\r\n            description: \"Move to next cell\",\r\n          },\r\n          {\r\n            keys: [\"Shift\", \"Tab\"],\r\n            description: \"Move to previous cell\",\r\n          },\r\n          {\r\n            keys: [\"Home\"],\r\n            description: \"Move to first column\",\r\n          },\r\n          {\r\n            keys: [\"End\"],\r\n            description: \"Move to last column\",\r\n          },\r\n          {\r\n            keys: [modKey, \"Home\"],\r\n            description: \"Move to first cell\",\r\n          },\r\n          {\r\n            keys: [modKey, \"End\"],\r\n            description: \"Move to last cell\",\r\n          },\r\n          {\r\n            keys: [\"PgUp\"],\r\n            description: \"Move up one page\",\r\n          },\r\n          {\r\n            keys: [\"PgDn\"],\r\n            description: \"Move down one page\",\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        title: \"Selection\",\r\n        shortcuts: [\r\n          {\r\n            keys: [\"Shift\", \"↑↓←→\"],\r\n            description: \"Extend selection\",\r\n          },\r\n          {\r\n            keys: [modKey, \"A\"],\r\n            description: \"Select all cells\",\r\n          },\r\n          {\r\n            keys: [modKey, \"Click\"],\r\n            description: \"Toggle cell selection\",\r\n          },\r\n          {\r\n            keys: [\"Shift\", \"Click\"],\r\n            description: \"Select range\",\r\n          },\r\n          {\r\n            keys: [\"Esc\"],\r\n            description: \"Clear selection\",\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        title: \"Editing\",\r\n        shortcuts: [\r\n          {\r\n            keys: [\"Enter\"],\r\n            description: \"Start editing cell\",\r\n          },\r\n          {\r\n            keys: [\"Double Click\"],\r\n            description: \"Start editing cell\",\r\n          },\r\n          {\r\n            keys: [\"Delete\"],\r\n            description: \"Clear selected cells\",\r\n          },\r\n          {\r\n            keys: [\"Backspace\"],\r\n            description: \"Clear selected cells\",\r\n          },\r\n        ],\r\n      },\r\n      ...(enableSearch\r\n        ? [\r\n            {\r\n              title: \"Search\",\r\n              shortcuts: [\r\n                {\r\n                  keys: [modKey, \"F\"],\r\n                  description: \"Open search\",\r\n                },\r\n                {\r\n                  keys: [\"Enter\"],\r\n                  description: \"Next match\",\r\n                },\r\n                {\r\n                  keys: [\"Shift\", \"Enter\"],\r\n                  description: \"Previous match\",\r\n                },\r\n                {\r\n                  keys: [\"Esc\"],\r\n                  description: \"Close search\",\r\n                },\r\n              ],\r\n            },\r\n          ]\r\n        : []),\r\n      {\r\n        title: \"Sorting\",\r\n        shortcuts: [\r\n          {\r\n            keys: [modKey, \"Shift\", \"S\"],\r\n            description: \"Toggle the sort menu\",\r\n          },\r\n          {\r\n            keys: [\"Backspace\"],\r\n            description: \"Remove sort (when focused)\",\r\n          },\r\n          {\r\n            keys: [\"Delete\"],\r\n            description: \"Remove sort (when focused)\",\r\n          },\r\n        ],\r\n      },\r\n      {\r\n        title: \"General\",\r\n        shortcuts: [\r\n          {\r\n            keys: [modKey, \"/\"],\r\n            description: \"Show keyboard shortcuts\",\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n    [modKey, enableSearch],\r\n  );\r\n\r\n  const filteredGroups = React.useMemo(() => {\r\n    if (!input.trim()) return shortcutGroups;\r\n\r\n    const query = input.toLowerCase();\r\n    return shortcutGroups\r\n      .map((group) => ({\r\n        ...group,\r\n        shortcuts: group.shortcuts.filter(\r\n          (shortcut) =>\r\n            shortcut.description.toLowerCase().includes(query) ||\r\n            shortcut.keys.some((key) => key.toLowerCase().includes(query)),\r\n        ),\r\n      }))\r\n      .filter((group) => group.shortcuts.length > 0);\r\n  }, [shortcutGroups, input]);\r\n\r\n  React.useEffect(() => {\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if ((event.ctrlKey || event.metaKey) && event.key === SHORTCUT_KEY) {\r\n        event.preventDefault();\r\n        setOpen(true);\r\n      }\r\n    }\r\n\r\n    window.addEventListener(\"keydown\", onKeyDown);\r\n    return () => {\r\n      window.removeEventListener(\"keydown\", onKeyDown);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onOpenChange}>\r\n      <DialogContent\r\n        className=\"max-w-2xl px-0\"\r\n        onOpenAutoFocus={onOpenAutoFocus}\r\n        showCloseButton={false}\r\n      >\r\n        <DialogClose className=\"absolute top-6 right-6\" asChild>\r\n          <Button variant=\"ghost\" size=\"icon\" className=\"size-6\">\r\n            <XIcon />\r\n          </Button>\r\n        </DialogClose>\r\n        <DialogHeader className=\"px-6\">\r\n          <DialogTitle>Keyboard shortcuts</DialogTitle>\r\n          <DialogDescription className=\"sr-only\">\r\n            Use these keyboard shortcuts to navigate and interact with the data\r\n            grid more efficiently.\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n        <div className=\"px-6\">\r\n          <div className=\"relative\">\r\n            <SearchIcon className=\"-translate-y-1/2 absolute top-1/2 left-3 size-3.5 text-muted-foreground\" />\r\n            <Input\r\n              ref={inputRef}\r\n              placeholder=\"Search shortcuts...\"\r\n              className=\"h-8 pl-8\"\r\n              value={input}\r\n              onChange={onInputChange}\r\n            />\r\n          </div>\r\n        </div>\r\n        <Separator className=\"mx-auto data-[orientation=horizontal]:w-[calc(100%-theme(spacing.12))]\" />\r\n        <div className=\"h-[40vh] overflow-y-auto px-6\">\r\n          {filteredGroups.length === 0 ? (\r\n            <div className=\"flex h-full flex-col items-center justify-center gap-3 text-center\">\r\n              <div className=\"flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground\">\r\n                <SearchIcon className=\"pointer-events-none size-6\" />\r\n              </div>\r\n              <div className=\"flex flex-col gap-1\">\r\n                <div className=\"font-medium text-lg tracking-tight\">\r\n                  No shortcuts found\r\n                </div>\r\n                <p className=\"text-muted-foreground text-sm\">\r\n                  Try searching for a different term.\r\n                </p>\r\n              </div>\r\n            </div>\r\n          ) : (\r\n            <div className=\"flex flex-col gap-6\">\r\n              {filteredGroups.map((shortcutGroup) => (\r\n                <div key={shortcutGroup.title} className=\"flex flex-col gap-2\">\r\n                  <h3 className=\"font-semibold text-foreground text-sm\">\r\n                    {shortcutGroup.title}\r\n                  </h3>\r\n                  <div className=\"divide-y divide-border rounded-md border\">\r\n                    {shortcutGroup.shortcuts.map((shortcut, index) => (\r\n                      <ShortcutCard\r\n                        key={index}\r\n                        keys={shortcut.keys}\r\n                        description={shortcut.description}\r\n                      />\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          )}\r\n        </div>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n\r\nfunction ShortcutCard({\r\n  keys,\r\n  description,\r\n}: ShortcutGroup[\"shortcuts\"][number]) {\r\n  return (\r\n    <div className=\"flex items-center gap-4 px-3 py-2\">\r\n      <span className=\"flex-1 text-sm\">{description}</span>\r\n      <KbdGroup className=\"shrink-0\">\r\n        {keys.map((key, index) => (\r\n          <React.Fragment key={key}>\r\n            {index > 0 && (\r\n              <span className=\"text-muted-foreground text-xs\">+</span>\r\n            )}\r\n            <Kbd>{key}</Kbd>\r\n          </React.Fragment>\r\n        ))}\r\n      </KbdGroup>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-keyboard-shortcuts.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-row.tsx",
      "content": "\"use client\";\r\n\r\nimport { flexRender, type Row } from \"@tanstack/react-table\";\r\nimport type { Virtualizer } from \"@tanstack/react-virtual\";\r\nimport * as React from \"react\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { getRowHeightValue } from \"@/lib/data-grid\";\r\nimport { getCommonPinningStyles } from \"@/lib/data-table\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport type { CellPosition, RowHeightValue } from \"@/types/data-grid\";\r\n\r\ninterface DataGridRowProps<TData> extends React.ComponentProps<\"div\"> {\r\n  row: Row<TData>;\r\n  rowVirtualizer: Virtualizer<HTMLDivElement, Element>;\r\n  virtualRowIndex: number;\r\n  rowMapRef: React.RefObject<Map<number, HTMLDivElement>>;\r\n  rowHeight: RowHeightValue;\r\n  focusedCell: CellPosition | null;\r\n}\r\n\r\nexport const DataGridRow = React.memo(DataGridRowImpl, (prev, next) => {\r\n  if (prev.row.id !== next.row.id) {\r\n    return false;\r\n  }\r\n\r\n  const prevRowIndex = prev.virtualRowIndex;\r\n  const nextRowIndex = next.virtualRowIndex;\r\n\r\n  const prevHasFocus = prev.focusedCell?.rowIndex === prevRowIndex;\r\n  const nextHasFocus = next.focusedCell?.rowIndex === nextRowIndex;\r\n\r\n  if (prevHasFocus !== nextHasFocus) {\r\n    return false;\r\n  }\r\n\r\n  if (nextHasFocus && prevHasFocus) {\r\n    const prevFocusedCol = prev.focusedCell?.columnId;\r\n    const nextFocusedCol = next.focusedCell?.columnId;\r\n    if (prevFocusedCol !== nextFocusedCol) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (next.rowVirtualizer.isScrolling) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}) as typeof DataGridRowImpl;\r\n\r\nfunction DataGridRowImpl<TData>({\r\n  row,\r\n  virtualRowIndex,\r\n  rowVirtualizer,\r\n  rowMapRef,\r\n  rowHeight,\r\n  focusedCell,\r\n  ref,\r\n  className,\r\n  ...props\r\n}: DataGridRowProps<TData>) {\r\n  const rowRef = useComposedRefs(ref, (node) => {\r\n    if (node && typeof virtualRowIndex !== \"undefined\") {\r\n      rowVirtualizer.measureElement(node);\r\n      rowMapRef.current.set(virtualRowIndex, node);\r\n    }\r\n  });\r\n\r\n  const isRowSelected = row.getIsSelected();\r\n\r\n  return (\r\n    <div\r\n      key={row.id}\r\n      role=\"row\"\r\n      aria-rowindex={virtualRowIndex + 2}\r\n      aria-selected={isRowSelected}\r\n      data-index={virtualRowIndex}\r\n      data-slot=\"grid-row\"\r\n      ref={rowRef}\r\n      tabIndex={-1}\r\n      className={cn(\"absolute flex w-full border-b\", className)}\r\n      style={{\r\n        height: `${getRowHeightValue(rowHeight)}px`,\r\n      }}\r\n      {...props}\r\n    >\r\n      {row.getVisibleCells().map((cell, colIndex) => {\r\n        const isCellFocused =\r\n          focusedCell?.rowIndex === virtualRowIndex &&\r\n          focusedCell?.columnId === cell.column.id;\r\n\r\n        return (\r\n          <div\r\n            key={cell.id}\r\n            role=\"gridcell\"\r\n            aria-colindex={colIndex + 1}\r\n            data-highlighted={isCellFocused ? \"\" : undefined}\r\n            data-slot=\"grid-cell\"\r\n            tabIndex={-1}\r\n            className={cn({\r\n              \"border-r\": cell.column.id !== \"select\",\r\n            })}\r\n            style={{\r\n              ...getCommonPinningStyles({ column: cell.column }),\r\n              width: `calc(var(--col-${cell.column.id}-size) * 1px)`,\r\n            }}\r\n          >\r\n            {typeof cell.column.columnDef.header === \"function\" ? (\r\n              <div\r\n                className={cn(\"size-full px-3 py-1.5\", {\r\n                  \"bg-primary/10\": isRowSelected,\r\n                })}\r\n              >\r\n                {flexRender(cell.column.columnDef.cell, cell.getContext())}\r\n              </div>\r\n            ) : (\r\n              flexRender(cell.column.columnDef.cell, cell.getContext())\r\n            )}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-row.tsx"
    },
    {
      "path": "src/components/data-grid/data-grid-search.tsx",
      "content": "\"use client\";\r\n\r\nimport { ChevronDown, ChevronUp, X } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { useDebouncedCallback } from \"@/hooks/use-debounced-callback\";\r\nimport type { SearchState } from \"@/types/data-grid\";\r\n\r\ninterface DataGridSearchProps extends SearchState {}\r\n\r\nexport const DataGridSearch = React.memo(DataGridSearchImpl, (prev, next) => {\r\n  if (prev.searchOpen !== next.searchOpen) return false;\r\n\r\n  if (!next.searchOpen) return true;\r\n\r\n  if (\r\n    prev.searchQuery !== next.searchQuery ||\r\n    prev.matchIndex !== next.matchIndex\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  if (prev.searchMatches.length !== next.searchMatches.length) return false;\r\n\r\n  for (let i = 0; i < prev.searchMatches.length; i++) {\r\n    const prevMatch = prev.searchMatches[i];\r\n    const nextMatch = next.searchMatches[i];\r\n\r\n    if (!prevMatch || !nextMatch) return false;\r\n\r\n    if (\r\n      prevMatch.rowIndex !== nextMatch.rowIndex ||\r\n      prevMatch.columnId !== nextMatch.columnId\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n});\r\n\r\nfunction DataGridSearchImpl({\r\n  searchMatches,\r\n  matchIndex,\r\n  searchOpen,\r\n  onSearchOpenChange,\r\n  searchQuery,\r\n  onSearchQueryChange,\r\n  onSearch,\r\n  onNavigateToNextMatch,\r\n  onNavigateToPrevMatch,\r\n}: DataGridSearchProps) {\r\n  const inputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  React.useEffect(() => {\r\n    if (searchOpen) {\r\n      requestAnimationFrame(() => {\r\n        inputRef.current?.focus();\r\n      });\r\n    }\r\n  }, [searchOpen]);\r\n\r\n  React.useEffect(() => {\r\n    if (!searchOpen) return;\r\n\r\n    function onEscape(event: KeyboardEvent) {\r\n      if (event.key === \"Escape\") {\r\n        event.preventDefault();\r\n        onSearchOpenChange(false);\r\n      }\r\n    }\r\n\r\n    document.addEventListener(\"keydown\", onEscape);\r\n    return () => document.removeEventListener(\"keydown\", onEscape);\r\n  }, [searchOpen, onSearchOpenChange]);\r\n\r\n  const onKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent) => {\r\n      event.stopPropagation();\r\n\r\n      if (event.key === \"Enter\") {\r\n        event.preventDefault();\r\n        if (event.shiftKey) {\r\n          onNavigateToPrevMatch();\r\n        } else {\r\n          onNavigateToNextMatch();\r\n        }\r\n      }\r\n    },\r\n    [onNavigateToNextMatch, onNavigateToPrevMatch],\r\n  );\r\n\r\n  const debouncedSearch = useDebouncedCallback((query: string) => {\r\n    onSearch(query);\r\n  }, 150);\r\n\r\n  const onChange = React.useCallback(\r\n    (event: React.ChangeEvent<HTMLInputElement>) => {\r\n      const value = event.target.value;\r\n      onSearchQueryChange(value);\r\n      debouncedSearch(value);\r\n    },\r\n    [onSearchQueryChange, debouncedSearch],\r\n  );\r\n\r\n  const onTriggerPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<HTMLButtonElement>) => {\r\n      // prevent implicit pointer capture\r\n      const target = event.target;\r\n      if (!(target instanceof HTMLElement)) return;\r\n      if (target.hasPointerCapture(event.pointerId)) {\r\n        target.releasePointerCapture(event.pointerId);\r\n      }\r\n\r\n      // Only prevent default if we're not clicking on the input\r\n      // This allows text selection in the input while still preventing focus stealing elsewhere\r\n      if (\r\n        event.button === 0 &&\r\n        event.ctrlKey === false &&\r\n        event.pointerType === \"mouse\" &&\r\n        !(event.target instanceof HTMLInputElement)\r\n      ) {\r\n        event.preventDefault();\r\n      }\r\n    },\r\n    [],\r\n  );\r\n\r\n  const onPrevMatchPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<HTMLButtonElement>) =>\r\n      onTriggerPointerDown(event),\r\n    [onTriggerPointerDown],\r\n  );\r\n\r\n  const onNextMatchPointerDown = React.useCallback(\r\n    (event: React.PointerEvent<HTMLButtonElement>) =>\r\n      onTriggerPointerDown(event),\r\n    [onTriggerPointerDown],\r\n  );\r\n\r\n  const onClose = React.useCallback(() => {\r\n    onSearchOpenChange(false);\r\n  }, [onSearchOpenChange]);\r\n\r\n  if (!searchOpen) return null;\r\n\r\n  return (\r\n    <div\r\n      role=\"search\"\r\n      data-slot=\"grid-search\"\r\n      className=\"fade-in-0 slide-in-from-top-2 absolute top-4 right-4 z-50 flex animate-in flex-col gap-2 rounded-lg border bg-background p-2 shadow-lg\"\r\n    >\r\n      <div className=\"flex items-center gap-2\">\r\n        <Input\r\n          autoComplete=\"off\"\r\n          autoCorrect=\"off\"\r\n          autoCapitalize=\"off\"\r\n          spellCheck={false}\r\n          placeholder=\"Find in table...\"\r\n          className=\"h-8 w-64\"\r\n          ref={inputRef}\r\n          value={searchQuery}\r\n          onChange={onChange}\r\n          onKeyDown={onKeyDown}\r\n        />\r\n        <div className=\"flex items-center gap-1\">\r\n          <Button\r\n            aria-label=\"Previous match\"\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className=\"size-7\"\r\n            onClick={onNavigateToPrevMatch}\r\n            onPointerDown={onPrevMatchPointerDown}\r\n            disabled={searchMatches.length === 0}\r\n          >\r\n            <ChevronUp />\r\n          </Button>\r\n          <Button\r\n            aria-label=\"Next match\"\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className=\"size-7\"\r\n            onClick={onNavigateToNextMatch}\r\n            onPointerDown={onNextMatchPointerDown}\r\n            disabled={searchMatches.length === 0}\r\n          >\r\n            <ChevronDown />\r\n          </Button>\r\n          <Button\r\n            aria-label=\"Close search\"\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            className=\"size-7\"\r\n            onClick={onClose}\r\n          >\r\n            <X />\r\n          </Button>\r\n        </div>\r\n      </div>\r\n      <div className=\"flex items-center gap-1 whitespace-nowrap text-muted-foreground text-xs\">\r\n        {searchMatches.length > 0 ? (\r\n          <span>\r\n            {matchIndex + 1} of {searchMatches.length}\r\n          </span>\r\n        ) : searchQuery ? (\r\n          <span>No results</span>\r\n        ) : (\r\n          <span>Type to search</span>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-search.tsx"
    },
    {
      "path": "src/hooks/use-callback-ref.ts",
      "content": "import * as React from \"react\";\n\n/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/use-callback-ref/src/useCallbackRef.tsx\n */\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: never[]) => unknown>(\n  callback: T | undefined,\n): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(\n    () => ((...args) => callbackRef.current?.(...args)) as T,\n    [],\n  );\n}\n\nexport { useCallbackRef };\n",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-data-grid.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  type ColumnDef,\r\n  getCoreRowModel,\r\n  getSortedRowModel,\r\n  type RowSelectionState,\r\n  type SortingState,\r\n  type TableOptions,\r\n  type Updater,\r\n  useReactTable,\r\n} from \"@tanstack/react-table\";\r\nimport { useVirtualizer, type Virtualizer } from \"@tanstack/react-virtual\";\r\nimport * as React from \"react\";\r\nimport { DataGridCell } from \"@/components/data-grid/data-grid-cell\";\r\nimport { getCellKey, getRowHeightValue, parseCellKey } from \"@/lib/data-grid\";\r\nimport type {\r\n  CellPosition,\r\n  ContextMenuState,\r\n  NavigationDirection,\r\n  RowHeightValue,\r\n  SearchState,\r\n  SelectionState,\r\n  UpdateCell,\r\n} from \"@/types/data-grid\";\r\n\r\nconst DEFAULT_ROW_HEIGHT = \"short\";\r\nconst OVERSCAN = 3;\r\nconst VIEWPORT_OFFSET = 1;\r\nconst MIN_COLUMN_SIZE = 60;\r\nconst MAX_COLUMN_SIZE = 800;\r\nconst SEARCH_SHORTCUT_KEY = \"f\";\r\nconst NON_NAVIGABLE_COLUMN_IDS = [\"select\", \"actions\"] as const;\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\r\n\r\nfunction useLazyRef<T>(fn: () => T): React.RefObject<T> {\r\n  const ref = React.useRef<T | null>(null);\r\n  if (ref.current === null) {\r\n    ref.current = fn();\r\n  }\r\n  return ref as React.RefObject<T>;\r\n}\r\n\r\nfunction useAsRef<T>(data: T) {\r\n  const ref = React.useRef<T>(data);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    ref.current = data;\r\n  });\r\n\r\n  return ref;\r\n}\r\n\r\ninterface DataGridState {\r\n  sorting: SortingState;\r\n  rowHeight: RowHeightValue;\r\n  rowSelection: RowSelectionState;\r\n  selectionState: SelectionState;\r\n  focusedCell: CellPosition | null;\r\n  editingCell: CellPosition | null;\r\n  contextMenu: ContextMenuState;\r\n  searchQuery: string;\r\n  searchMatches: CellPosition[];\r\n  matchIndex: number;\r\n  searchOpen: boolean;\r\n  lastClickedRowIndex: number | null;\r\n  isScrolling: boolean;\r\n}\r\n\r\ninterface DataGridStore {\r\n  subscribe: (callback: () => void) => () => void;\r\n  getState: () => DataGridState;\r\n  setState: <K extends keyof DataGridState>(\r\n    key: K,\r\n    value: DataGridState[K],\r\n  ) => void;\r\n  notify: () => void;\r\n  batch: (fn: () => void) => void;\r\n}\r\n\r\nfunction useStore<T>(\r\n  store: DataGridStore,\r\n  selector: (state: DataGridState) => T,\r\n): T {\r\n  const getSnapshot = React.useCallback(\r\n    () => selector(store.getState()),\r\n    [store, selector],\r\n  );\r\n\r\n  return React.useSyncExternalStore(store.subscribe, getSnapshot, getSnapshot);\r\n}\r\n\r\ninterface UseDataGridProps<TData>\r\n  extends Omit<TableOptions<TData>, \"pageCount\" | \"getCoreRowModel\"> {\r\n  onDataChange?: (data: TData[]) => void;\r\n  rowHeight?: RowHeightValue;\r\n  overscan?: number;\r\n  autoFocus?: boolean | Partial<CellPosition>;\r\n  enableColumnSelection?: boolean;\r\n  enableSearch?: boolean;\r\n}\r\n\r\nexport function useDataGrid<TData>({\r\n  columns,\r\n  data,\r\n  onDataChange,\r\n  rowHeight: rowHeightProp = DEFAULT_ROW_HEIGHT,\r\n  overscan = OVERSCAN,\r\n  initialState,\r\n  autoFocus = false,\r\n  enableColumnSelection = false,\r\n  enableSearch = false,\r\n  ...dataGridProps\r\n}: UseDataGridProps<TData>) {\r\n  const dataGridRef = React.useRef<HTMLDivElement>(null);\r\n  const tableRef = React.useRef<ReturnType<typeof useReactTable<TData>>>(null);\r\n  const rowVirtualizerRef =\r\n    React.useRef<Virtualizer<HTMLDivElement, Element>>(null);\r\n  const headerRef = React.useRef<HTMLDivElement>(null);\r\n  const rowMapRef = React.useRef<Map<number, HTMLDivElement>>(new Map());\r\n  const footerRef = React.useRef<HTMLDivElement>(null);\r\n\r\n  const dataGridPropsRef = useAsRef(dataGridProps);\r\n  const listenersRef = useLazyRef(() => new Set<() => void>());\r\n\r\n  const stateRef = useLazyRef<DataGridState>(() => {\r\n    return {\r\n      sorting: initialState?.sorting ?? [],\r\n      rowHeight: rowHeightProp,\r\n      rowSelection: initialState?.rowSelection ?? {},\r\n      selectionState: {\r\n        selectedCells: new Set(),\r\n        selectionRange: null,\r\n        isSelecting: false,\r\n      },\r\n      focusedCell: null,\r\n      editingCell: null,\r\n      contextMenu: {\r\n        open: false,\r\n        x: 0,\r\n        y: 0,\r\n      },\r\n      searchQuery: \"\",\r\n      searchMatches: [],\r\n      matchIndex: -1,\r\n      searchOpen: false,\r\n      lastClickedRowIndex: null,\r\n      isScrolling: false,\r\n    };\r\n  });\r\n\r\n  const store = React.useMemo<DataGridStore>(() => {\r\n    let isBatching = false;\r\n    let pendingNotification = false;\r\n\r\n    return {\r\n      subscribe: (callback) => {\r\n        listenersRef.current.add(callback);\r\n        return () => listenersRef.current.delete(callback);\r\n      },\r\n      getState: () => stateRef.current,\r\n      setState: (key, value) => {\r\n        if (Object.is(stateRef.current[key], value)) return;\r\n        stateRef.current[key] = value;\r\n\r\n        if (isBatching) {\r\n          pendingNotification = true;\r\n        } else {\r\n          if (!pendingNotification) {\r\n            pendingNotification = true;\r\n            queueMicrotask(() => {\r\n              pendingNotification = false;\r\n              store.notify();\r\n            });\r\n          }\r\n        }\r\n      },\r\n      notify: () => {\r\n        for (const listener of listenersRef.current) {\r\n          listener();\r\n        }\r\n      },\r\n      batch: (fn) => {\r\n        if (isBatching) {\r\n          fn();\r\n          return;\r\n        }\r\n\r\n        isBatching = true;\r\n        const wasPending = pendingNotification;\r\n        pendingNotification = false;\r\n\r\n        try {\r\n          fn();\r\n        } finally {\r\n          isBatching = false;\r\n          if (pendingNotification || wasPending) {\r\n            pendingNotification = false;\r\n            store.notify();\r\n          }\r\n        }\r\n      },\r\n    };\r\n  }, [listenersRef, stateRef]);\r\n\r\n  const focusedCell = useStore(store, (state) => state.focusedCell);\r\n  const editingCell = useStore(store, (state) => state.editingCell);\r\n  const selectionState = useStore(store, (state) => state.selectionState);\r\n  const searchQuery = useStore(store, (state) => state.searchQuery);\r\n  const searchMatches = useStore(store, (state) => state.searchMatches);\r\n  const matchIndex = useStore(store, (state) => state.matchIndex);\r\n  const searchOpen = useStore(store, (state) => state.searchOpen);\r\n  const sorting = useStore(store, (state) => state.sorting);\r\n  const rowSelection = useStore(store, (state) => state.rowSelection);\r\n  const contextMenu = useStore(store, (state) => state.contextMenu);\r\n  const rowHeight = useStore(store, (state) => state.rowHeight);\r\n  const isScrolling = useStore(store, (state) => state.isScrolling);\r\n\r\n  const rowHeightValue = getRowHeightValue(rowHeight);\r\n\r\n  const columnIds = React.useMemo(() => {\r\n    return columns\r\n      .map((c) => {\r\n        if (c.id) return c.id;\r\n        if (\"accessorKey\" in c) return c.accessorKey as string;\r\n        return undefined;\r\n      })\r\n      .filter((id): id is string => Boolean(id));\r\n  }, [columns]);\r\n\r\n  const navigableColumnIds = React.useMemo(() => {\r\n    return columnIds.filter((c) => !NON_NAVIGABLE_COLUMN_IDS.includes(c));\r\n  }, [columnIds]);\r\n\r\n  const onDataUpdate = React.useCallback(\r\n    (updates: UpdateCell | Array<UpdateCell>) => {\r\n      const updateArray = Array.isArray(updates) ? updates : [updates];\r\n\r\n      if (updateArray.length === 0) return;\r\n\r\n      const currentTable = tableRef.current;\r\n      const rows = currentTable?.getRowModel().rows;\r\n\r\n      const rowUpdatesMap = new Map<\r\n        number,\r\n        Array<Omit<UpdateCell, \"rowIndex\">>\r\n      >();\r\n\r\n      for (const update of updateArray) {\r\n        if (!rows || !currentTable) {\r\n          const existingUpdates = rowUpdatesMap.get(update.rowIndex) ?? [];\r\n          existingUpdates.push({\r\n            columnId: update.columnId,\r\n            value: update.value,\r\n          });\r\n          rowUpdatesMap.set(update.rowIndex, existingUpdates);\r\n        } else {\r\n          const row = rows[update.rowIndex];\r\n          if (!row) continue;\r\n\r\n          const originalData = row.original;\r\n          const originalRowIndex = data.indexOf(originalData);\r\n          if (originalRowIndex === -1) continue;\r\n\r\n          const existingUpdates = rowUpdatesMap.get(originalRowIndex) ?? [];\r\n          existingUpdates.push({\r\n            columnId: update.columnId,\r\n            value: update.value,\r\n          });\r\n          rowUpdatesMap.set(originalRowIndex, existingUpdates);\r\n        }\r\n      }\r\n\r\n      const newData = data.map((row, index) => {\r\n        const updates = rowUpdatesMap.get(index);\r\n        if (!updates) return row;\r\n\r\n        const updatedRow = { ...row } as Record<string, unknown>;\r\n        for (const { columnId, value } of updates) {\r\n          updatedRow[columnId] = value;\r\n        }\r\n        return updatedRow as TData;\r\n      });\r\n\r\n      onDataChange?.(newData);\r\n    },\r\n    [data, onDataChange],\r\n  );\r\n\r\n  const getIsCellSelected = React.useCallback(\r\n    (rowIndex: number, columnId: string) => {\r\n      return selectionState.selectedCells.has(getCellKey(rowIndex, columnId));\r\n    },\r\n    [selectionState.selectedCells],\r\n  );\r\n\r\n  const clearSelection = React.useCallback(() => {\r\n    store.batch(() => {\r\n      store.setState(\"selectionState\", {\r\n        selectedCells: new Set(),\r\n        selectionRange: null,\r\n        isSelecting: false,\r\n      });\r\n      store.setState(\"rowSelection\", {});\r\n    });\r\n  }, [store]);\r\n\r\n  const selectAll = React.useCallback(() => {\r\n    const allCells = new Set<string>();\r\n    const currentTable = tableRef.current;\r\n    const rows = currentTable?.getRowModel().rows ?? [];\r\n    const rowCount = rows.length ?? data.length;\r\n\r\n    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\r\n      for (const columnId of columnIds) {\r\n        allCells.add(getCellKey(rowIndex, columnId));\r\n      }\r\n    }\r\n\r\n    const firstColumnId = columnIds[0];\r\n    const lastColumnId = columnIds[columnIds.length - 1];\r\n\r\n    store.setState(\"selectionState\", {\r\n      selectedCells: allCells,\r\n      selectionRange:\r\n        columnIds.length > 0 && rowCount > 0 && firstColumnId && lastColumnId\r\n          ? {\r\n              start: { rowIndex: 0, columnId: firstColumnId },\r\n              end: { rowIndex: rowCount - 1, columnId: lastColumnId },\r\n            }\r\n          : null,\r\n      isSelecting: false,\r\n    });\r\n  }, [columnIds, data.length, store]);\r\n\r\n  const selectColumn = React.useCallback(\r\n    (columnId: string) => {\r\n      const currentTable = tableRef.current;\r\n      const rows = currentTable?.getRowModel().rows ?? [];\r\n      const rowCount = rows.length ?? data.length;\r\n\r\n      if (rowCount === 0) return;\r\n\r\n      const selectedCells = new Set<string>();\r\n\r\n      for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\r\n        selectedCells.add(getCellKey(rowIndex, columnId));\r\n      }\r\n\r\n      store.setState(\"selectionState\", {\r\n        selectedCells,\r\n        selectionRange: {\r\n          start: { rowIndex: 0, columnId },\r\n          end: { rowIndex: rowCount - 1, columnId },\r\n        },\r\n        isSelecting: false,\r\n      });\r\n    },\r\n    [data.length, store],\r\n  );\r\n\r\n  const selectRange = React.useCallback(\r\n    (start: CellPosition, end: CellPosition, isSelecting = false) => {\r\n      const startColIndex = columnIds.indexOf(start.columnId);\r\n      const endColIndex = columnIds.indexOf(end.columnId);\r\n\r\n      const minRow = Math.min(start.rowIndex, end.rowIndex);\r\n      const maxRow = Math.max(start.rowIndex, end.rowIndex);\r\n      const minCol = Math.min(startColIndex, endColIndex);\r\n      const maxCol = Math.max(startColIndex, endColIndex);\r\n\r\n      const selectedCells = new Set<string>();\r\n\r\n      for (let rowIndex = minRow; rowIndex <= maxRow; rowIndex++) {\r\n        for (let colIndex = minCol; colIndex <= maxCol; colIndex++) {\r\n          const columnId = columnIds[colIndex];\r\n          if (columnId) {\r\n            selectedCells.add(getCellKey(rowIndex, columnId));\r\n          }\r\n        }\r\n      }\r\n\r\n      store.setState(\"selectionState\", {\r\n        selectedCells,\r\n        selectionRange: { start, end },\r\n        isSelecting,\r\n      });\r\n    },\r\n    [columnIds, store],\r\n  );\r\n\r\n  const focusCell = React.useCallback(\r\n    (rowIndex: number, columnId: string) => {\r\n      store.batch(() => {\r\n        store.setState(\"focusedCell\", { rowIndex, columnId });\r\n        store.setState(\"editingCell\", null);\r\n      });\r\n\r\n      const currentState = store.getState();\r\n\r\n      if (currentState.searchOpen) return;\r\n\r\n      if (\r\n        dataGridRef.current &&\r\n        document.activeElement !== dataGridRef.current\r\n      ) {\r\n        dataGridRef.current.focus();\r\n      }\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const navigateCell = React.useCallback(\r\n    (direction: NavigationDirection) => {\r\n      const currentState = store.getState();\r\n      if (!currentState.focusedCell) return;\r\n\r\n      const { rowIndex, columnId } = currentState.focusedCell;\r\n      const currentColIndex = navigableColumnIds.indexOf(columnId);\r\n      const rowVirtualizer = rowVirtualizerRef.current;\r\n      const currentTable = tableRef.current;\r\n      const rows = currentTable?.getRowModel().rows ?? [];\r\n      const rowCount = rows.length ?? data.length;\r\n\r\n      let newRowIndex = rowIndex;\r\n      let newColumnId = columnId;\r\n\r\n      switch (direction) {\r\n        case \"up\":\r\n          newRowIndex = Math.max(0, rowIndex - 1);\r\n          break;\r\n        case \"down\":\r\n          newRowIndex = Math.min(rowCount - 1, rowIndex + 1);\r\n          break;\r\n        case \"left\":\r\n          if (currentColIndex > 0) {\r\n            const prevColumnId = navigableColumnIds[currentColIndex - 1];\r\n            if (prevColumnId) newColumnId = prevColumnId;\r\n          }\r\n          break;\r\n        case \"right\":\r\n          if (currentColIndex < navigableColumnIds.length - 1) {\r\n            const nextColumnId = navigableColumnIds[currentColIndex + 1];\r\n            if (nextColumnId) newColumnId = nextColumnId;\r\n          }\r\n          break;\r\n        case \"home\":\r\n          if (navigableColumnIds.length > 0) {\r\n            newColumnId = navigableColumnIds[0] ?? columnId;\r\n          }\r\n          break;\r\n        case \"end\":\r\n          if (navigableColumnIds.length > 0) {\r\n            newColumnId =\r\n              navigableColumnIds[navigableColumnIds.length - 1] ?? columnId;\r\n          }\r\n          break;\r\n        case \"ctrl+home\":\r\n          newRowIndex = 0;\r\n          if (navigableColumnIds.length > 0) {\r\n            newColumnId = navigableColumnIds[0] ?? columnId;\r\n          }\r\n          break;\r\n        case \"ctrl+end\":\r\n          newRowIndex = Math.max(0, rowCount - 1);\r\n          if (navigableColumnIds.length > 0) {\r\n            newColumnId =\r\n              navigableColumnIds[navigableColumnIds.length - 1] ?? columnId;\r\n          }\r\n          break;\r\n        case \"pageup\":\r\n          if (rowVirtualizer) {\r\n            const visibleRange = rowVirtualizer.getVirtualItems();\r\n            const pageSize = visibleRange.length ?? 10;\r\n            newRowIndex = Math.max(0, rowIndex - pageSize);\r\n          } else {\r\n            newRowIndex = Math.max(0, rowIndex - 10);\r\n          }\r\n          break;\r\n        case \"pagedown\":\r\n          if (rowVirtualizer) {\r\n            const visibleRange = rowVirtualizer.getVirtualItems();\r\n            const pageSize = visibleRange.length ?? 10;\r\n            newRowIndex = Math.min(rowCount - 1, rowIndex + pageSize);\r\n          } else {\r\n            newRowIndex = Math.min(rowCount - 1, rowIndex + 10);\r\n          }\r\n          break;\r\n      }\r\n\r\n      if (newRowIndex !== rowIndex || newColumnId !== columnId) {\r\n        const rowDiff = newRowIndex - rowIndex;\r\n\r\n        // For single-row vertical navigation (up/down arrows)\r\n        if (\r\n          Math.abs(rowDiff) === 1 &&\r\n          (direction === \"up\" || direction === \"down\")\r\n        ) {\r\n          const container = dataGridRef.current;\r\n          const currentRow = rowMapRef.current.get(rowIndex);\r\n          const targetRow = rowMapRef.current.get(newRowIndex);\r\n\r\n          if (!container || !currentRow) {\r\n            // Fallback to simple focus if we can't find elements\r\n            focusCell(newRowIndex, newColumnId);\r\n            return;\r\n          }\r\n\r\n          // Check viewport boundaries\r\n          const containerRect = container.getBoundingClientRect();\r\n          const headerHeight =\r\n            headerRef.current?.getBoundingClientRect().height ?? 0;\r\n          const footerHeight =\r\n            footerRef.current?.getBoundingClientRect().height ?? 0;\r\n\r\n          const viewportTop =\r\n            containerRect.top + headerHeight + VIEWPORT_OFFSET;\r\n          const viewportBottom =\r\n            containerRect.bottom - footerHeight - VIEWPORT_OFFSET;\r\n\r\n          // If target row already exists, check if it's visible\r\n          if (targetRow) {\r\n            const rowRect = targetRow.getBoundingClientRect();\r\n            const isFullyVisible =\r\n              rowRect.top >= viewportTop && rowRect.bottom <= viewportBottom;\r\n\r\n            if (isFullyVisible) {\r\n              // Row is fully visible, just focus it\r\n              focusCell(newRowIndex, newColumnId);\r\n              return;\r\n            }\r\n\r\n            // Row exists but not fully visible, scroll it into view\r\n            focusCell(newRowIndex, newColumnId);\r\n\r\n            if (direction === \"down\") {\r\n              // Scroll just enough to show the row at the bottom\r\n              const scrollNeeded = rowRect.bottom - viewportBottom;\r\n              container.scrollTop += scrollNeeded;\r\n            } else {\r\n              // Scroll just enough to show the row at the top\r\n              const scrollNeeded = viewportTop - rowRect.top;\r\n              container.scrollTop -= scrollNeeded;\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Target row is not rendered yet\r\n          // Focus immediately so the ring appears as the row is revealed\r\n          focusCell(newRowIndex, newColumnId);\r\n\r\n          // Scroll by exactly one row height to reveal it smoothly\r\n          if (direction === \"down\") {\r\n            container.scrollTop += rowHeightValue;\r\n          } else {\r\n            // For arrow up, ensure we don't go below 0\r\n            const currentScrollTop = container.scrollTop;\r\n            const targetScrollTop = Math.max(\r\n              0,\r\n              currentScrollTop - rowHeightValue,\r\n            );\r\n            container.scrollTop = targetScrollTop;\r\n          }\r\n          return;\r\n        }\r\n\r\n        // For larger jumps (page up/down, ctrl+home/end, etc.)\r\n        if (rowVirtualizer && Math.abs(rowDiff) > 1) {\r\n          const align =\r\n            direction === \"pageup\" || direction === \"ctrl+home\"\r\n              ? \"start\"\r\n              : direction === \"pagedown\" || direction === \"ctrl+end\"\r\n                ? \"end\"\r\n                : \"center\";\r\n          rowVirtualizer.scrollToIndex(newRowIndex, { align });\r\n          requestAnimationFrame(() => {\r\n            focusCell(newRowIndex, newColumnId);\r\n          });\r\n          return;\r\n        }\r\n\r\n        // For horizontal navigation or when row is already visible\r\n        focusCell(newRowIndex, newColumnId);\r\n      }\r\n    },\r\n    [store, navigableColumnIds, focusCell, data.length, rowHeightValue],\r\n  );\r\n\r\n  const onCellEditingStart = React.useCallback(\r\n    (rowIndex: number, columnId: string) => {\r\n      store.batch(() => {\r\n        store.setState(\"focusedCell\", { rowIndex, columnId });\r\n        store.setState(\"editingCell\", { rowIndex, columnId });\r\n      });\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const onCellEditingStop = React.useCallback(\r\n    (opts?: { moveToNextRow?: boolean; direction?: NavigationDirection }) => {\r\n      const currentState = store.getState();\r\n      const currentEditing = currentState.editingCell;\r\n\r\n      store.setState(\"editingCell\", null);\r\n\r\n      if (opts?.moveToNextRow && currentEditing) {\r\n        const { rowIndex, columnId } = currentEditing;\r\n        const currentTable = tableRef.current;\r\n        const rows = currentTable?.getRowModel().rows ?? [];\r\n        const rowCount = rows.length ?? data.length;\r\n\r\n        const nextRowIndex = rowIndex + 1;\r\n        if (nextRowIndex < rowCount) {\r\n          requestAnimationFrame(() => {\r\n            focusCell(nextRowIndex, columnId);\r\n          });\r\n        }\r\n      } else if (opts?.direction && currentEditing) {\r\n        // Focus the current editing cell first, then navigate\r\n        const { rowIndex, columnId } = currentEditing;\r\n        focusCell(rowIndex, columnId);\r\n        requestAnimationFrame(() => {\r\n          navigateCell(opts.direction ?? \"right\");\r\n        });\r\n      }\r\n    },\r\n    [store, data.length, focusCell, navigateCell],\r\n  );\r\n\r\n  const onSearchOpenChange = React.useCallback(\r\n    (open: boolean) => {\r\n      if (open) {\r\n        store.setState(\"searchOpen\", true);\r\n        return;\r\n      }\r\n\r\n      const currentState = store.getState();\r\n      const currentMatch =\r\n        currentState.matchIndex >= 0 &&\r\n        currentState.searchMatches[currentState.matchIndex];\r\n\r\n      store.batch(() => {\r\n        store.setState(\"searchOpen\", false);\r\n        store.setState(\"searchQuery\", \"\");\r\n        store.setState(\"searchMatches\", []);\r\n        store.setState(\"matchIndex\", -1);\r\n\r\n        if (currentMatch) {\r\n          store.setState(\"focusedCell\", {\r\n            rowIndex: currentMatch.rowIndex,\r\n            columnId: currentMatch.columnId,\r\n          });\r\n        }\r\n      });\r\n\r\n      if (\r\n        dataGridRef.current &&\r\n        document.activeElement !== dataGridRef.current\r\n      ) {\r\n        dataGridRef.current.focus();\r\n      }\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const onSearch = React.useCallback(\r\n    (query: string) => {\r\n      if (!query.trim()) {\r\n        store.batch(() => {\r\n          store.setState(\"searchMatches\", []);\r\n          store.setState(\"matchIndex\", -1);\r\n        });\r\n        return;\r\n      }\r\n\r\n      const matches: CellPosition[] = [];\r\n      const currentTable = tableRef.current;\r\n      const rows = currentTable?.getRowModel().rows ?? [];\r\n\r\n      const lowerQuery = query.toLowerCase();\r\n\r\n      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\r\n        const row = rows[rowIndex];\r\n        if (!row) continue;\r\n\r\n        for (const columnId of columnIds) {\r\n          const cell = row\r\n            .getVisibleCells()\r\n            .find((c) => c.column.id === columnId);\r\n          if (!cell) continue;\r\n\r\n          const value = cell.getValue();\r\n          const stringValue = String(value ?? \"\").toLowerCase();\r\n\r\n          if (stringValue.includes(lowerQuery)) {\r\n            matches.push({ rowIndex, columnId });\r\n          }\r\n        }\r\n      }\r\n\r\n      store.batch(() => {\r\n        store.setState(\"searchMatches\", matches);\r\n        store.setState(\"matchIndex\", matches.length > 0 ? 0 : -1);\r\n      });\r\n\r\n      // Scroll to first match but don't focus it (to keep focus in search input)\r\n      if (matches.length > 0 && matches[0]) {\r\n        const firstMatch = matches[0];\r\n        rowVirtualizerRef.current?.scrollToIndex(firstMatch.rowIndex, {\r\n          align: \"center\",\r\n        });\r\n      }\r\n    },\r\n    [columnIds, store],\r\n  );\r\n\r\n  const onSearchQueryChange = React.useCallback(\r\n    (query: string) => store.setState(\"searchQuery\", query),\r\n    [store],\r\n  );\r\n\r\n  const onNavigateToPrevMatch = React.useCallback(() => {\r\n    const currentState = store.getState();\r\n    if (currentState.searchMatches.length === 0) return;\r\n\r\n    const prevIndex =\r\n      currentState.matchIndex - 1 < 0\r\n        ? currentState.searchMatches.length - 1\r\n        : currentState.matchIndex - 1;\r\n    const match = currentState.searchMatches[prevIndex];\r\n\r\n    if (match) {\r\n      rowVirtualizerRef.current?.scrollToIndex(match.rowIndex, {\r\n        align: \"center\",\r\n      });\r\n\r\n      requestAnimationFrame(() => {\r\n        store.setState(\"matchIndex\", prevIndex);\r\n        requestAnimationFrame(() => {\r\n          focusCell(match.rowIndex, match.columnId);\r\n        });\r\n      });\r\n    }\r\n  }, [store, focusCell]);\r\n\r\n  const onNavigateToNextMatch = React.useCallback(() => {\r\n    const currentState = store.getState();\r\n    if (currentState.searchMatches.length === 0) return;\r\n\r\n    const nextIndex =\r\n      (currentState.matchIndex + 1) % currentState.searchMatches.length;\r\n    const match = currentState.searchMatches[nextIndex];\r\n\r\n    if (match) {\r\n      rowVirtualizerRef.current?.scrollToIndex(match.rowIndex, {\r\n        align: \"center\",\r\n      });\r\n\r\n      requestAnimationFrame(() => {\r\n        store.setState(\"matchIndex\", nextIndex);\r\n        requestAnimationFrame(() => {\r\n          focusCell(match.rowIndex, match.columnId);\r\n        });\r\n      });\r\n    }\r\n  }, [store, focusCell]);\r\n\r\n  const getIsSearchMatch = React.useCallback(\r\n    (rowIndex: number, columnId: string) => {\r\n      return searchMatches.some(\r\n        (match) => match.rowIndex === rowIndex && match.columnId === columnId,\r\n      );\r\n    },\r\n    [searchMatches],\r\n  );\r\n\r\n  const getIsActiveSearchMatch = React.useCallback(\r\n    (rowIndex: number, columnId: string) => {\r\n      if (matchIndex < 0) return false;\r\n      const currentMatch = searchMatches[matchIndex];\r\n      return (\r\n        currentMatch?.rowIndex === rowIndex &&\r\n        currentMatch?.columnId === columnId\r\n      );\r\n    },\r\n    [searchMatches, matchIndex],\r\n  );\r\n\r\n  const blurCell = React.useCallback(() => {\r\n    const currentState = store.getState();\r\n    if (\r\n      currentState.editingCell &&\r\n      document.activeElement instanceof HTMLElement\r\n    ) {\r\n      document.activeElement.blur();\r\n    }\r\n\r\n    store.batch(() => {\r\n      store.setState(\"focusedCell\", null);\r\n      store.setState(\"editingCell\", null);\r\n    });\r\n  }, [store]);\r\n\r\n  const onCellClick = React.useCallback(\r\n    (rowIndex: number, columnId: string, event?: React.MouseEvent) => {\r\n      // Ignore right-click (button 2) - let onCellContextMenu handle it\r\n      if (event?.button === 2) {\r\n        return;\r\n      }\r\n\r\n      const currentState = store.getState();\r\n      const currentFocused = currentState.focusedCell;\r\n\r\n      if (event) {\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          const cellKey = getCellKey(rowIndex, columnId);\r\n          const newSelectedCells = new Set(\r\n            currentState.selectionState.selectedCells,\r\n          );\r\n\r\n          if (newSelectedCells.has(cellKey)) {\r\n            newSelectedCells.delete(cellKey);\r\n          } else {\r\n            newSelectedCells.add(cellKey);\r\n          }\r\n\r\n          store.setState(\"selectionState\", {\r\n            selectedCells: newSelectedCells,\r\n            selectionRange: null,\r\n            isSelecting: false,\r\n          });\r\n          focusCell(rowIndex, columnId);\r\n          return;\r\n        }\r\n\r\n        if (event.shiftKey && currentState.focusedCell) {\r\n          event.preventDefault();\r\n          selectRange(currentState.focusedCell, { rowIndex, columnId });\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Clear selection if there are selected cells or rows\r\n      const hasSelectedCells =\r\n        currentState.selectionState.selectedCells.size > 0;\r\n      const hasSelectedRows = Object.keys(currentState.rowSelection).length > 0;\r\n\r\n      if (hasSelectedCells && !currentState.selectionState.isSelecting) {\r\n        // If there's a cell selection but we're not actively selecting (drag just finished),\r\n        // don't clear it - keep the selection\r\n        // Only clear if clicking elsewhere\r\n        const cellKey = getCellKey(rowIndex, columnId);\r\n        const isClickingSelectedCell =\r\n          currentState.selectionState.selectedCells.has(cellKey);\r\n\r\n        if (!isClickingSelectedCell) {\r\n          clearSelection();\r\n        } else {\r\n          // Clicking on an already selected cell - just focus it\r\n          focusCell(rowIndex, columnId);\r\n          return;\r\n        }\r\n      } else if (hasSelectedRows && columnId !== \"select\") {\r\n        // If there are selected rows but we're clicking on a non-checkbox cell, clear selections\r\n        clearSelection();\r\n      }\r\n\r\n      if (\r\n        currentFocused?.rowIndex === rowIndex &&\r\n        currentFocused?.columnId === columnId\r\n      ) {\r\n        onCellEditingStart(rowIndex, columnId);\r\n      } else {\r\n        focusCell(rowIndex, columnId);\r\n      }\r\n    },\r\n    [store, focusCell, onCellEditingStart, selectRange, clearSelection],\r\n  );\r\n\r\n  const onCellDoubleClick = React.useCallback(\r\n    (rowIndex: number, columnId: string, event?: React.MouseEvent) => {\r\n      if (event?.defaultPrevented) return;\r\n\r\n      onCellEditingStart(rowIndex, columnId);\r\n    },\r\n    [onCellEditingStart],\r\n  );\r\n\r\n  const onCellMouseDown = React.useCallback(\r\n    (rowIndex: number, columnId: string, event: React.MouseEvent) => {\r\n      // Ignore right-click (button 2) - let onCellContextMenu handle it\r\n      if (event.button === 2) {\r\n        return;\r\n      }\r\n\r\n      event.preventDefault();\r\n\r\n      // Only start drag selection if no modifier keys are pressed\r\n      // Clear any existing selection and prepare for potential drag\r\n      if (!event.ctrlKey && !event.metaKey && !event.shiftKey) {\r\n        store.batch(() => {\r\n          store.setState(\"selectionState\", {\r\n            selectedCells: new Set(),\r\n            selectionRange: {\r\n              start: { rowIndex, columnId },\r\n              end: { rowIndex, columnId },\r\n            },\r\n            isSelecting: true,\r\n          });\r\n          store.setState(\"rowSelection\", {});\r\n        });\r\n      }\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const onCellMouseEnter = React.useCallback(\r\n    (rowIndex: number, columnId: string, _event: React.MouseEvent) => {\r\n      const currentState = store.getState();\r\n      if (\r\n        currentState.selectionState.isSelecting &&\r\n        currentState.selectionState.selectionRange\r\n      ) {\r\n        const start = currentState.selectionState.selectionRange.start;\r\n        const end = { rowIndex, columnId };\r\n\r\n        if (\r\n          currentState.focusedCell?.rowIndex !== start.rowIndex ||\r\n          currentState.focusedCell?.columnId !== start.columnId\r\n        ) {\r\n          focusCell(start.rowIndex, start.columnId);\r\n        }\r\n\r\n        selectRange(start, end, true);\r\n      }\r\n    },\r\n    [store, selectRange, focusCell],\r\n  );\r\n\r\n  const onCellMouseUp = React.useCallback(() => {\r\n    const currentState = store.getState();\r\n    store.setState(\"selectionState\", {\r\n      ...currentState.selectionState,\r\n      isSelecting: false,\r\n    });\r\n  }, [store]);\r\n\r\n  const onCellContextMenu = React.useCallback(\r\n    (rowIndex: number, columnId: string, event: React.MouseEvent) => {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n\r\n      const currentState = store.getState();\r\n      const cellKey = getCellKey(rowIndex, columnId);\r\n      const isTargetCellSelected =\r\n        currentState.selectionState.selectedCells.has(cellKey);\r\n\r\n      // If right-clicking on a non-selected cell, select only that cell\r\n      if (!isTargetCellSelected) {\r\n        store.batch(() => {\r\n          store.setState(\"selectionState\", {\r\n            selectedCells: new Set([cellKey]),\r\n            selectionRange: {\r\n              start: { rowIndex, columnId },\r\n              end: { rowIndex, columnId },\r\n            },\r\n            isSelecting: false,\r\n          });\r\n          store.setState(\"focusedCell\", { rowIndex, columnId });\r\n        });\r\n      }\r\n\r\n      // Open context menu at cursor position\r\n      store.setState(\"contextMenu\", {\r\n        open: true,\r\n        x: event.clientX,\r\n        y: event.clientY,\r\n      });\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const onContextMenuOpenChange = React.useCallback(\r\n    (open: boolean) => {\r\n      if (!open) {\r\n        const currentMenu = store.getState().contextMenu;\r\n        store.setState(\"contextMenu\", {\r\n          open: false,\r\n          x: currentMenu.x,\r\n          y: currentMenu.y,\r\n        });\r\n      }\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const onDataGridKeyDown = React.useCallback(\r\n    (event: KeyboardEvent) => {\r\n      const currentState = store.getState();\r\n      const { key, ctrlKey, metaKey, shiftKey } = event;\r\n      const isCtrlPressed = ctrlKey || metaKey;\r\n\r\n      // Handle Cmd+F / Ctrl+F to open search (highest priority, works even when editing)\r\n      if (enableSearch && isCtrlPressed && key === SEARCH_SHORTCUT_KEY) {\r\n        event.preventDefault();\r\n        onSearchOpenChange(true);\r\n        return;\r\n      }\r\n\r\n      // Handle search navigation when search is open\r\n      if (\r\n        enableSearch &&\r\n        currentState.searchOpen &&\r\n        !currentState.editingCell\r\n      ) {\r\n        if (key === \"Enter\") {\r\n          event.preventDefault();\r\n          if (shiftKey) {\r\n            onNavigateToPrevMatch();\r\n          } else {\r\n            onNavigateToNextMatch();\r\n          }\r\n          return;\r\n        }\r\n        if (key === \"Escape\") {\r\n          event.preventDefault();\r\n          onSearchOpenChange(false);\r\n          return;\r\n        }\r\n        // When search is open, don't let data grid handle any other keys\r\n        // (they should only affect the search input)\r\n        return;\r\n      }\r\n\r\n      if (currentState.editingCell) return;\r\n\r\n      if (!currentState.focusedCell) return;\r\n\r\n      let direction: NavigationDirection | null = null;\r\n\r\n      if (isCtrlPressed && key === \"a\") {\r\n        event.preventDefault();\r\n        selectAll();\r\n        return;\r\n      }\r\n\r\n      if (key === \"Delete\" || key === \"Backspace\") {\r\n        if (currentState.selectionState.selectedCells.size > 0) {\r\n          event.preventDefault();\r\n          const updates: Array<{\r\n            rowIndex: number;\r\n            columnId: string;\r\n            value: unknown;\r\n          }> = [];\r\n\r\n          currentState.selectionState.selectedCells.forEach((cellKey) => {\r\n            const { rowIndex, columnId } = parseCellKey(cellKey);\r\n            updates.push({ rowIndex, columnId, value: \"\" });\r\n          });\r\n\r\n          onDataUpdate(updates);\r\n          clearSelection();\r\n        }\r\n        return;\r\n      }\r\n\r\n      switch (key) {\r\n        case \"ArrowUp\":\r\n          direction = \"up\";\r\n          break;\r\n        case \"ArrowDown\":\r\n          direction = \"down\";\r\n          break;\r\n        case \"ArrowLeft\":\r\n          direction = \"left\";\r\n          break;\r\n        case \"ArrowRight\":\r\n          direction = \"right\";\r\n          break;\r\n        case \"Home\":\r\n          direction = isCtrlPressed ? \"ctrl+home\" : \"home\";\r\n          break;\r\n        case \"End\":\r\n          direction = isCtrlPressed ? \"ctrl+end\" : \"end\";\r\n          break;\r\n        case \"PageUp\":\r\n          direction = \"pageup\";\r\n          break;\r\n        case \"PageDown\":\r\n          direction = \"pagedown\";\r\n          break;\r\n        case \"Escape\":\r\n          event.preventDefault();\r\n          if (\r\n            currentState.selectionState.selectedCells.size > 0 ||\r\n            Object.keys(currentState.rowSelection).length > 0\r\n          ) {\r\n            clearSelection();\r\n          } else {\r\n            blurCell();\r\n          }\r\n          return;\r\n        case \"Tab\":\r\n          event.preventDefault();\r\n          direction = event.shiftKey ? \"left\" : \"right\";\r\n          break;\r\n      }\r\n\r\n      if (direction) {\r\n        event.preventDefault();\r\n\r\n        // Tab navigation should not trigger selection, even with Shift\r\n        if (shiftKey && key !== \"Tab\" && currentState.focusedCell) {\r\n          const currentColIndex = navigableColumnIds.indexOf(\r\n            currentState.focusedCell.columnId,\r\n          );\r\n          let newRowIndex = currentState.focusedCell.rowIndex;\r\n          let newColumnId = currentState.focusedCell.columnId;\r\n\r\n          switch (direction) {\r\n            case \"up\":\r\n              newRowIndex = Math.max(0, currentState.focusedCell.rowIndex - 1);\r\n              break;\r\n            case \"down\":\r\n              newRowIndex = Math.min(\r\n                (tableRef.current?.getRowModel().rows.length || data.length) -\r\n                  1,\r\n                currentState.focusedCell.rowIndex + 1,\r\n              );\r\n              break;\r\n            case \"left\":\r\n              if (currentColIndex > 0) {\r\n                const prevColumnId = navigableColumnIds[currentColIndex - 1];\r\n                if (prevColumnId) newColumnId = prevColumnId;\r\n              }\r\n              break;\r\n            case \"right\":\r\n              if (currentColIndex < navigableColumnIds.length - 1) {\r\n                const nextColumnId = navigableColumnIds[currentColIndex + 1];\r\n                if (nextColumnId) newColumnId = nextColumnId;\r\n              }\r\n              break;\r\n          }\r\n\r\n          const selectionStart =\r\n            currentState.selectionState.selectionRange?.start ||\r\n            currentState.focusedCell;\r\n          selectRange(selectionStart, {\r\n            rowIndex: newRowIndex,\r\n            columnId: newColumnId,\r\n          });\r\n          focusCell(newRowIndex, newColumnId);\r\n        } else {\r\n          if (currentState.selectionState.selectedCells.size > 0) {\r\n            clearSelection();\r\n          }\r\n          navigateCell(direction);\r\n        }\r\n      }\r\n    },\r\n    [\r\n      store,\r\n      blurCell,\r\n      navigateCell,\r\n      selectAll,\r\n      onDataUpdate,\r\n      clearSelection,\r\n      navigableColumnIds,\r\n      data.length,\r\n      selectRange,\r\n      focusCell,\r\n      onSearchOpenChange,\r\n      onNavigateToNextMatch,\r\n      onNavigateToPrevMatch,\r\n      enableSearch,\r\n    ],\r\n  );\r\n\r\n  const onSortingChange = React.useCallback(\r\n    (updater: Updater<SortingState>) => {\r\n      const currentState = store.getState();\r\n      const newSorting =\r\n        typeof updater === \"function\" ? updater(currentState.sorting) : updater;\r\n      store.setState(\"sorting\", newSorting);\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const onRowSelectionChange = React.useCallback(\r\n    (updater: Updater<RowSelectionState>) => {\r\n      const currentState = store.getState();\r\n      const newRowSelection =\r\n        typeof updater === \"function\"\r\n          ? updater(currentState.rowSelection)\r\n          : updater;\r\n\r\n      const selectedRows = Object.keys(newRowSelection).filter(\r\n        (key) => newRowSelection[key],\r\n      );\r\n\r\n      const selectedCells = new Set<string>();\r\n      const rows = tableRef.current?.getRowModel().rows ?? [];\r\n\r\n      for (const rowId of selectedRows) {\r\n        const rowIndex = rows.findIndex((r) => r.id === rowId);\r\n        if (rowIndex === -1) continue;\r\n\r\n        for (const columnId of columnIds) {\r\n          selectedCells.add(getCellKey(rowIndex, columnId));\r\n        }\r\n      }\r\n\r\n      store.batch(() => {\r\n        store.setState(\"rowSelection\", newRowSelection);\r\n        store.setState(\"selectionState\", {\r\n          selectedCells,\r\n          selectionRange: null,\r\n          isSelecting: false,\r\n        });\r\n        store.setState(\"focusedCell\", null);\r\n        store.setState(\"editingCell\", null);\r\n      });\r\n    },\r\n    [store, columnIds],\r\n  );\r\n\r\n  const onRowSelect = React.useCallback(\r\n    (rowIndex: number, selected: boolean, shiftKey: boolean) => {\r\n      const currentState = store.getState();\r\n      const rows = tableRef.current?.getRowModel().rows ?? [];\r\n      const currentRow = rows[rowIndex];\r\n      if (!currentRow) return;\r\n\r\n      if (shiftKey && currentState.lastClickedRowIndex !== null) {\r\n        const startIndex = Math.min(currentState.lastClickedRowIndex, rowIndex);\r\n        const endIndex = Math.max(currentState.lastClickedRowIndex, rowIndex);\r\n\r\n        const newRowSelection: RowSelectionState = {\r\n          ...currentState.rowSelection,\r\n        };\r\n\r\n        for (let i = startIndex; i <= endIndex; i++) {\r\n          const row = rows[i];\r\n          if (row) {\r\n            newRowSelection[row.id] = selected;\r\n          }\r\n        }\r\n\r\n        onRowSelectionChange(newRowSelection);\r\n      } else {\r\n        onRowSelectionChange({\r\n          ...currentState.rowSelection,\r\n          [currentRow.id]: selected,\r\n        });\r\n      }\r\n\r\n      store.setState(\"lastClickedRowIndex\", rowIndex);\r\n    },\r\n    [store, onRowSelectionChange],\r\n  );\r\n\r\n  const onRowHeightChange = React.useCallback(\r\n    (updater: Updater<RowHeightValue>) => {\r\n      const currentState = store.getState();\r\n      const newRowHeight =\r\n        typeof updater === \"function\"\r\n          ? updater(currentState.rowHeight)\r\n          : updater;\r\n      store.setState(\"rowHeight\", newRowHeight);\r\n    },\r\n    [store],\r\n  );\r\n\r\n  const onColumnClick = React.useCallback(\r\n    (columnId: string) => {\r\n      if (!enableColumnSelection) {\r\n        clearSelection();\r\n        return;\r\n      }\r\n\r\n      selectColumn(columnId);\r\n    },\r\n    [enableColumnSelection, selectColumn, clearSelection],\r\n  );\r\n\r\n  const defaultColumn: Partial<ColumnDef<TData>> = React.useMemo(\r\n    () => ({\r\n      cell: DataGridCell,\r\n      minSize: MIN_COLUMN_SIZE,\r\n      maxSize: MAX_COLUMN_SIZE,\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const tableOptions = React.useMemo<TableOptions<TData>>(\r\n    () => ({\r\n      ...dataGridPropsRef.current,\r\n      data,\r\n      columns,\r\n      defaultColumn,\r\n      initialState,\r\n      state: {\r\n        ...dataGridPropsRef.current.state,\r\n        sorting,\r\n        rowSelection,\r\n      },\r\n      onRowSelectionChange,\r\n      onSortingChange,\r\n      columnResizeMode: \"onChange\",\r\n      getCoreRowModel: getCoreRowModel(),\r\n      getSortedRowModel: getSortedRowModel(),\r\n      meta: {\r\n        ...dataGridPropsRef.current.meta,\r\n        dataGridRef,\r\n        focusedCell,\r\n        editingCell,\r\n        selectionState,\r\n        searchOpen,\r\n        isScrolling,\r\n        getIsCellSelected,\r\n        getIsSearchMatch,\r\n        getIsActiveSearchMatch,\r\n        onDataUpdate,\r\n        onColumnClick,\r\n        onCellClick,\r\n        onCellDoubleClick,\r\n        onCellMouseDown,\r\n        onCellMouseEnter,\r\n        onCellMouseUp,\r\n        onCellContextMenu,\r\n        onCellEditingStart,\r\n        onCellEditingStop,\r\n        contextMenu,\r\n        onContextMenuOpenChange,\r\n        rowHeight,\r\n        onRowHeightChange,\r\n        onRowSelect,\r\n      },\r\n    }),\r\n    [\r\n      dataGridPropsRef,\r\n      data,\r\n      columns,\r\n      defaultColumn,\r\n      initialState,\r\n      sorting,\r\n      rowSelection,\r\n      onRowSelectionChange,\r\n      onSortingChange,\r\n      focusedCell,\r\n      editingCell,\r\n      selectionState,\r\n      searchOpen,\r\n      isScrolling,\r\n      getIsCellSelected,\r\n      getIsSearchMatch,\r\n      getIsActiveSearchMatch,\r\n      onDataUpdate,\r\n      onColumnClick,\r\n      onCellClick,\r\n      onCellDoubleClick,\r\n      onCellMouseDown,\r\n      onCellMouseEnter,\r\n      onCellMouseUp,\r\n      onCellContextMenu,\r\n      onCellEditingStart,\r\n      onCellEditingStop,\r\n      contextMenu,\r\n      onContextMenuOpenChange,\r\n      rowHeight,\r\n      onRowHeightChange,\r\n      onRowSelect,\r\n    ],\r\n  );\r\n\r\n  const table = useReactTable(tableOptions);\r\n\r\n  if (!tableRef.current) {\r\n    tableRef.current = table;\r\n  }\r\n\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we need to memoize the column size vars\r\n  const columnSizeVars = React.useMemo(() => {\r\n    const headers = table.getFlatHeaders();\r\n    const colSizes: { [key: string]: number } = {};\r\n    for (const header of headers) {\r\n      colSizes[`--header-${header.id}-size`] = header.getSize();\r\n      colSizes[`--col-${header.column.id}-size`] = header.column.getSize();\r\n    }\r\n    return colSizes;\r\n  }, [table.getState().columnSizingInfo, table.getState().columnSizing]);\r\n\r\n  const rowVirtualizer = useVirtualizer({\r\n    count: table.getRowModel().rows.length,\r\n    getScrollElement: () => dataGridRef.current,\r\n    estimateSize: () => rowHeightValue,\r\n    overscan,\r\n    measureElement:\r\n      typeof window !== \"undefined\" &&\r\n      navigator.userAgent.indexOf(\"Firefox\") === -1\r\n        ? (element) => element?.getBoundingClientRect().height\r\n        : undefined,\r\n    onChange: (instance) => {\r\n      // Sync virtualizer's isScrolling state to our store\r\n      const virtualizerIsScrolling = instance.isScrolling;\r\n      const currentIsScrolling = store.getState().isScrolling;\r\n\r\n      if (virtualizerIsScrolling !== currentIsScrolling) {\r\n        store.setState(\"isScrolling\", virtualizerIsScrolling);\r\n      }\r\n\r\n      // Batch DOM updates in a single animation frame\r\n      const virtualItems = instance.getVirtualItems();\r\n      if (virtualItems.length === 0) return;\r\n\r\n      requestAnimationFrame(() => {\r\n        for (let i = 0; i < virtualItems.length; i++) {\r\n          const virtualRow = virtualItems[i];\r\n          if (!virtualRow) continue;\r\n          const rowRef = rowMapRef.current.get(virtualRow.index);\r\n          if (rowRef) {\r\n            rowRef.style.transform = `translateY(${virtualRow.start}px)`;\r\n          }\r\n        }\r\n      });\r\n    },\r\n  });\r\n\r\n  if (!rowVirtualizerRef.current) {\r\n    rowVirtualizerRef.current = rowVirtualizer;\r\n  }\r\n\r\n  const scrollToRow = React.useCallback(\r\n    async (opts: Partial<CellPosition>) => {\r\n      const rowIndex = opts?.rowIndex ?? 0;\r\n      const columnId = opts?.columnId;\r\n\r\n      rowVirtualizer.scrollToIndex(rowIndex, {\r\n        align: \"center\",\r\n      });\r\n\r\n      const targetColumnId = columnId ?? navigableColumnIds[0];\r\n\r\n      if (!targetColumnId) return;\r\n\r\n      queueMicrotask(() => {\r\n        requestAnimationFrame(() => {\r\n          requestAnimationFrame(() => {\r\n            store.batch(() => {\r\n              store.setState(\"focusedCell\", {\r\n                rowIndex,\r\n                columnId: targetColumnId,\r\n              });\r\n              store.setState(\"editingCell\", null);\r\n            });\r\n          });\r\n        });\r\n      });\r\n    },\r\n    [rowVirtualizer, navigableColumnIds, store],\r\n  );\r\n\r\n  const searchState = React.useMemo<SearchState | undefined>(() => {\r\n    if (!enableSearch) return undefined;\r\n\r\n    return {\r\n      searchMatches,\r\n      matchIndex,\r\n      searchOpen,\r\n      onSearchOpenChange,\r\n      searchQuery,\r\n      onSearchQueryChange,\r\n      onSearch,\r\n      onNavigateToNextMatch,\r\n      onNavigateToPrevMatch,\r\n    };\r\n  }, [\r\n    enableSearch,\r\n    searchMatches,\r\n    matchIndex,\r\n    searchOpen,\r\n    onSearchOpenChange,\r\n    searchQuery,\r\n    onSearchQueryChange,\r\n    onSearch,\r\n    onNavigateToNextMatch,\r\n    onNavigateToPrevMatch,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    const dataGridElement = dataGridRef.current;\r\n    if (!dataGridElement) return;\r\n\r\n    dataGridElement.addEventListener(\"keydown\", onDataGridKeyDown);\r\n    return () => {\r\n      dataGridElement.removeEventListener(\"keydown\", onDataGridKeyDown);\r\n    };\r\n  }, [onDataGridKeyDown]);\r\n\r\n  React.useEffect(() => {\r\n    function onGlobalKeyDown(event: KeyboardEvent) {\r\n      const dataGridElement = dataGridRef.current;\r\n      if (!dataGridElement) return;\r\n\r\n      const target = event.target;\r\n      if (!(target instanceof HTMLElement)) return;\r\n\r\n      const { key, ctrlKey, metaKey } = event;\r\n      const isCtrlPressed = ctrlKey || metaKey;\r\n\r\n      if (enableSearch && isCtrlPressed && key === SEARCH_SHORTCUT_KEY) {\r\n        const isInInput =\r\n          target.tagName === \"INPUT\" || target.tagName === \"TEXTAREA\";\r\n        const isInDataGrid = dataGridElement.contains(target);\r\n        const isInSearchInput = target.closest('[role=\"search\"]') !== null;\r\n\r\n        if (isInDataGrid || isInSearchInput || !isInInput) {\r\n          event.preventDefault();\r\n          event.stopPropagation();\r\n          onSearchOpenChange(true);\r\n\r\n          if (!isInDataGrid && !isInSearchInput) {\r\n            requestAnimationFrame(() => {\r\n              dataGridElement.focus();\r\n            });\r\n          }\r\n          return;\r\n        }\r\n      }\r\n\r\n      const isInDataGrid = dataGridElement.contains(target);\r\n      if (!isInDataGrid) return;\r\n\r\n      if (key === \"Escape\") {\r\n        const currentState = store.getState();\r\n        const hasSelections =\r\n          currentState.selectionState.selectedCells.size > 0 ||\r\n          Object.keys(currentState.rowSelection).length > 0;\r\n\r\n        if (hasSelections) {\r\n          event.preventDefault();\r\n          event.stopPropagation();\r\n          clearSelection();\r\n        }\r\n      }\r\n    }\r\n\r\n    window.addEventListener(\"keydown\", onGlobalKeyDown, true);\r\n    return () => {\r\n      window.removeEventListener(\"keydown\", onGlobalKeyDown, true);\r\n    };\r\n  }, [enableSearch, onSearchOpenChange, store, clearSelection]);\r\n\r\n  React.useEffect(() => {\r\n    const currentState = store.getState();\r\n    if (\r\n      autoFocus &&\r\n      data.length > 0 &&\r\n      columns.length > 0 &&\r\n      !currentState.focusedCell\r\n    ) {\r\n      if (navigableColumnIds.length > 0) {\r\n        const rafId = requestAnimationFrame(() => {\r\n          if (typeof autoFocus === \"object\") {\r\n            const { rowIndex, columnId } = autoFocus;\r\n            if (columnId) {\r\n              focusCell(rowIndex ?? 0, columnId);\r\n            }\r\n            return;\r\n          }\r\n\r\n          const firstColumnId = navigableColumnIds[0];\r\n          if (firstColumnId) {\r\n            focusCell(0, firstColumnId);\r\n          }\r\n        });\r\n        return () => cancelAnimationFrame(rafId);\r\n      }\r\n    }\r\n  }, [\r\n    autoFocus,\r\n    data.length,\r\n    columns.length,\r\n    store,\r\n    navigableColumnIds,\r\n    focusCell,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    function onOutsideClick(event: MouseEvent) {\r\n      if (event.button === 2) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        dataGridRef.current &&\r\n        !dataGridRef.current.contains(event.target as Node)\r\n      ) {\r\n        const target = event.target;\r\n        const isInsidePopover =\r\n          target instanceof HTMLElement &&\r\n          (target.closest(\"[data-grid-cell-editor]\") ||\r\n            target.closest(\"[data-grid-popover]\"));\r\n\r\n        if (!isInsidePopover) {\r\n          blurCell();\r\n          const currentState = store.getState();\r\n          if (\r\n            currentState.selectionState.selectedCells.size > 0 ||\r\n            Object.keys(currentState.rowSelection).length > 0\r\n          ) {\r\n            clearSelection();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    document.addEventListener(\"mousedown\", onOutsideClick);\r\n    return () => {\r\n      document.removeEventListener(\"mousedown\", onOutsideClick);\r\n    };\r\n  }, [store, blurCell, clearSelection]);\r\n\r\n  React.useEffect(() => {\r\n    function cleanup() {\r\n      document.removeEventListener(\"selectstart\", preventSelection);\r\n      document.removeEventListener(\"contextmenu\", preventContextMenu);\r\n      document.body.style.userSelect = \"\";\r\n    }\r\n\r\n    function preventSelection(event: Event) {\r\n      event.preventDefault();\r\n    }\r\n    function preventContextMenu(event: Event) {\r\n      event.preventDefault();\r\n    }\r\n\r\n    const unsubscribe = store.subscribe(() => {\r\n      const currentState = store.getState();\r\n      if (currentState.selectionState.isSelecting) {\r\n        document.addEventListener(\"selectstart\", preventSelection);\r\n        document.addEventListener(\"contextmenu\", preventContextMenu);\r\n        document.body.style.userSelect = \"none\";\r\n      } else {\r\n        cleanup();\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      cleanup();\r\n      unsubscribe();\r\n    };\r\n  }, [store]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const rafId = requestAnimationFrame(() => {\r\n      rowVirtualizer.measure();\r\n    });\r\n    return () => cancelAnimationFrame(rafId);\r\n  }, [\r\n    table.getState().columnFilters,\r\n    table.getState().columnOrder,\r\n    table.getState().columnPinning,\r\n    table.getState().columnSizing,\r\n    table.getState().columnVisibility,\r\n    table.getState().expanded,\r\n    table.getState().globalFilter,\r\n    table.getState().grouping,\r\n    table.getState().rowSelection,\r\n    table.getState().sorting,\r\n    rowHeight,\r\n  ]);\r\n\r\n  return {\r\n    dataGridRef,\r\n    headerRef,\r\n    rowMapRef,\r\n    footerRef,\r\n    table,\r\n    rowVirtualizer,\r\n    searchState,\r\n    columnSizeVars,\r\n    scrollToRow,\r\n  };\r\n}\r\n",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-debounced-callback.ts",
      "content": "/**\n * @see https://github.com/mantinedev/mantine/blob/master/packages/@mantine/hooks/src/use-debounced-callback/use-debounced-callback.ts\n */\n\nimport * as React from \"react\";\n\nimport { useCallbackRef } from \"@/hooks/use-callback-ref\";\n\nexport function useDebouncedCallback<T extends (...args: never[]) => unknown>(\n  callback: T,\n  delay: number,\n) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = React.useRef(0);\n  React.useEffect(\n    () => () => window.clearTimeout(debounceTimerRef.current),\n    [],\n  );\n\n  const setValue = React.useCallback(\n    (...args: Parameters<T>) => {\n      window.clearTimeout(debounceTimerRef.current);\n      debounceTimerRef.current = window.setTimeout(\n        () => handleCallback(...args),\n        delay,\n      );\n    },\n    [handleCallback, delay],\n  );\n\n  return setValue;\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "src/lib/compose-refs.ts",
      "content": "/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\nimport * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we don't want to re-run this callback when the refs change\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/data-grid.ts",
      "content": "import type { CellPosition, RowHeightValue } from \"@/types/data-grid\";\r\n\r\nexport function getCellKey(rowIndex: number, columnId: string) {\r\n  return `${rowIndex}:${columnId}`;\r\n}\r\n\r\nexport function parseCellKey(cellKey: string): Required<CellPosition> {\r\n  const parts = cellKey.split(\":\");\r\n  const rowIndexStr = parts[0];\r\n  const columnId = parts[1];\r\n  if (rowIndexStr && columnId) {\r\n    const rowIndex = parseInt(rowIndexStr, 10);\r\n    if (!Number.isNaN(rowIndex)) {\r\n      return { rowIndex, columnId };\r\n    }\r\n  }\r\n  return { rowIndex: 0, columnId: \"\" };\r\n}\r\n\r\nexport function getRowHeightValue(rowHeight: RowHeightValue): number {\r\n  const rowHeightMap: Record<RowHeightValue, number> = {\r\n    short: 36,\r\n    medium: 56,\r\n    tall: 76,\r\n    \"extra-tall\": 96,\r\n  };\r\n\r\n  return rowHeightMap[rowHeight];\r\n}\r\n\r\nexport function getLineCount(rowHeight: RowHeightValue): number {\r\n  const lineCountMap: Record<RowHeightValue, number> = {\r\n    short: 1,\r\n    medium: 2,\r\n    tall: 3,\r\n    \"extra-tall\": 4,\r\n  };\r\n\r\n  return lineCountMap[rowHeight];\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "src/types/data-grid.ts",
      "content": "import type { RowData } from \"@tanstack/react-table\";\r\n\r\nexport type RowHeightValue = \"short\" | \"medium\" | \"tall\" | \"extra-tall\";\r\n\r\nexport interface CellSelectOption {\r\n  label: string;\r\n  value: string;\r\n}\r\n\r\nexport type Cell =\r\n  | {\r\n      variant: \"short-text\";\r\n    }\r\n  | {\r\n      variant: \"long-text\";\r\n    }\r\n  | {\r\n      variant: \"number\";\r\n      min?: number;\r\n      max?: number;\r\n      step?: number;\r\n    }\r\n  | {\r\n      variant: \"select\";\r\n      options: CellSelectOption[];\r\n    }\r\n  | {\r\n      variant: \"multi-select\";\r\n      options: CellSelectOption[];\r\n    }\r\n  | {\r\n      variant: \"checkbox\";\r\n    }\r\n  | {\r\n      variant: \"date\";\r\n    };\r\n\r\nexport interface UpdateCell {\r\n  rowIndex: number;\r\n  columnId: string;\r\n  value: unknown;\r\n}\r\n\r\ndeclare module \"@tanstack/react-table\" {\r\n  // biome-ignore lint/correctness/noUnusedVariables: TData and TValue are used in the ColumnMeta interface\r\n  interface ColumnMeta<TData extends RowData, TValue> {\r\n    label?: string;\r\n    cell?: Cell;\r\n  }\r\n\r\n  // biome-ignore lint/correctness/noUnusedVariables: TData is used in the TableMeta interface\r\n  interface TableMeta<TData extends RowData> {\r\n    dataGridRef?: React.RefObject<HTMLElement | null>;\r\n    focusedCell?: CellPosition | null;\r\n    editingCell?: CellPosition | null;\r\n    selectionState?: SelectionState;\r\n    searchOpen?: boolean;\r\n    isScrolling?: boolean;\r\n    getIsCellSelected?: (rowIndex: number, columnId: string) => boolean;\r\n    getIsSearchMatch?: (rowIndex: number, columnId: string) => boolean;\r\n    getIsActiveSearchMatch?: (rowIndex: number, columnId: string) => boolean;\r\n    onDataUpdate?: (props: UpdateCell | Array<UpdateCell>) => void;\r\n    onColumnClick?: (columnId: string) => void;\r\n    onCellClick?: (\r\n      rowIndex: number,\r\n      columnId: string,\r\n      event?: React.MouseEvent,\r\n    ) => void;\r\n    onCellDoubleClick?: (rowIndex: number, columnId: string) => void;\r\n    onCellMouseDown?: (\r\n      rowIndex: number,\r\n      columnId: string,\r\n      event: React.MouseEvent,\r\n    ) => void;\r\n    onCellMouseEnter?: (\r\n      rowIndex: number,\r\n      columnId: string,\r\n      event: React.MouseEvent,\r\n    ) => void;\r\n    onCellMouseUp?: () => void;\r\n    onCellContextMenu?: (\r\n      rowIndex: number,\r\n      columnId: string,\r\n      event: React.MouseEvent,\r\n    ) => void;\r\n    onCellEditingStart?: (rowIndex: number, columnId: string) => void;\r\n    onCellEditingStop?: (opts?: {\r\n      direction?: NavigationDirection;\r\n      moveToNextRow?: boolean;\r\n    }) => void;\r\n    contextMenu?: ContextMenuState;\r\n    onContextMenuOpenChange?: (open: boolean) => void;\r\n    rowHeight?: RowHeightValue;\r\n    onRowHeightChange?: (value: RowHeightValue) => void;\r\n    onRowSelect?: (\r\n      rowIndex: number,\r\n      checked: boolean,\r\n      shiftKey: boolean,\r\n    ) => void;\r\n  }\r\n}\r\n\r\nexport interface CellPosition {\r\n  rowIndex: number;\r\n  columnId: string;\r\n}\r\n\r\nexport interface CellRange {\r\n  start: CellPosition;\r\n  end: CellPosition;\r\n}\r\n\r\nexport interface SelectionState {\r\n  selectedCells: Set<string>;\r\n  selectionRange: CellRange | null;\r\n  isSelecting: boolean;\r\n}\r\n\r\nexport interface ContextMenuState {\r\n  open: boolean;\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport type NavigationDirection =\r\n  | \"up\"\r\n  | \"down\"\r\n  | \"left\"\r\n  | \"right\"\r\n  | \"home\"\r\n  | \"end\"\r\n  | \"ctrl+home\"\r\n  | \"ctrl+end\"\r\n  | \"pageup\"\r\n  | \"pagedown\";\r\n\r\nexport interface SearchState {\r\n  searchMatches: CellPosition[];\r\n  matchIndex: number;\r\n  searchOpen: boolean;\r\n  onSearchOpenChange: (open: boolean) => void;\r\n  searchQuery: string;\r\n  onSearchQueryChange: (query: string) => void;\r\n  onSearch: (query: string) => void;\r\n  onNavigateToNextMatch: () => void;\r\n  onNavigateToPrevMatch: () => void;\r\n}\r\n",
      "type": "registry:file",
      "target": "src/types/data-grid.ts"
    }
  ]
}