{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-grid-sort-menu",
  "type": "registry:component",
  "title": "Data Grid Sort Menu",
  "description": "A sort menu component for the data grid with drag-and-drop reordering",
  "dependencies": [
    "@tanstack/react-table",
    "lucide-react"
  ],
  "registryDependencies": [
    "badge",
    "button",
    "command",
    "popover",
    "select"
  ],
  "files": [
    {
      "path": "src/components/data-grid/data-grid-sort-menu.tsx",
      "content": "\"use client\";\r\n\r\nimport type { ColumnSort, SortDirection, Table } from \"@tanstack/react-table\";\r\nimport {\r\n  ArrowDownUp,\r\n  ChevronsUpDown,\r\n  GripVertical,\r\n  Trash2,\r\n} from \"lucide-react\";\r\nimport * as React from \"react\";\r\n\r\nimport { Badge } from \"@/components/ui/badge\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from \"@/components/ui/command\";\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@/components/ui/popover\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from \"@/components/ui/select\";\r\nimport {\r\n  Sortable,\r\n  SortableContent,\r\n  SortableItem,\r\n  SortableItemHandle,\r\n  SortableOverlay,\r\n} from \"@/components/ui/sortable\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst SORT_SHORTCUT_KEY = \"s\";\r\nconst REMOVE_SORT_SHORTCUTS = [\"backspace\", \"delete\"];\r\n\r\nconst SORT_ORDERS = [\r\n  { label: \"Asc\", value: \"asc\" },\r\n  { label: \"Desc\", value: \"desc\" },\r\n];\r\n\r\ninterface DataGridSortMenuProps<TData>\r\n  extends React.ComponentProps<typeof PopoverContent> {\r\n  table: Table<TData>;\r\n}\r\n\r\nexport function DataGridSortMenu<TData>({\r\n  table,\r\n  ...props\r\n}: DataGridSortMenuProps<TData>) {\r\n  const id = React.useId();\r\n  const labelId = React.useId();\r\n  const descriptionId = React.useId();\r\n  const [open, setOpen] = React.useState(false);\r\n  const addButtonRef = React.useRef<HTMLButtonElement>(null);\r\n\r\n  const sorting = table.getState().sorting;\r\n  const onSortingChange = table.setSorting;\r\n\r\n  const { columnLabels, columns } = React.useMemo(() => {\r\n    const labels = new Map<string, string>();\r\n    const sortingIds = new Set(sorting.map((s) => s.id));\r\n    const availableColumns: { id: string; label: string }[] = [];\r\n\r\n    for (const column of table.getAllColumns()) {\r\n      if (!column.getCanSort()) continue;\r\n\r\n      const label = column.columnDef.meta?.label ?? column.id;\r\n      labels.set(column.id, label);\r\n\r\n      if (!sortingIds.has(column.id)) {\r\n        availableColumns.push({ id: column.id, label });\r\n      }\r\n    }\r\n\r\n    return {\r\n      columnLabels: labels,\r\n      columns: availableColumns,\r\n    };\r\n  }, [sorting, table]);\r\n\r\n  const onSortAdd = React.useCallback(() => {\r\n    const firstColumn = columns[0];\r\n    if (!firstColumn) return;\r\n\r\n    onSortingChange((prevSorting) => [\r\n      ...prevSorting,\r\n      { id: firstColumn.id, desc: false },\r\n    ]);\r\n  }, [columns, onSortingChange]);\r\n\r\n  const onSortUpdate = React.useCallback(\r\n    (sortId: string, updates: Partial<ColumnSort>) => {\r\n      onSortingChange((prevSorting) => {\r\n        if (!prevSorting) return prevSorting;\r\n        return prevSorting.map((sort) =>\r\n          sort.id === sortId ? { ...sort, ...updates } : sort,\r\n        );\r\n      });\r\n    },\r\n    [onSortingChange],\r\n  );\r\n\r\n  const onSortRemove = React.useCallback(\r\n    (sortId: string) => {\r\n      onSortingChange((prevSorting) =>\r\n        prevSorting.filter((item) => item.id !== sortId),\r\n      );\r\n    },\r\n    [onSortingChange],\r\n  );\r\n\r\n  const onSortingReset = React.useCallback(\r\n    () => onSortingChange(table.initialState.sorting),\r\n    [onSortingChange, table.initialState.sorting],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (\r\n        event.target instanceof HTMLInputElement ||\r\n        event.target instanceof HTMLTextAreaElement ||\r\n        (event.target instanceof HTMLElement &&\r\n          event.target.contentEditable === \"true\")\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        event.key.toLowerCase() === SORT_SHORTCUT_KEY &&\r\n        (event.ctrlKey || event.metaKey) &&\r\n        event.shiftKey\r\n      ) {\r\n        event.preventDefault();\r\n        setOpen((prev) => !prev);\r\n      }\r\n    }\r\n\r\n    window.addEventListener(\"keydown\", onKeyDown);\r\n    return () => window.removeEventListener(\"keydown\", onKeyDown);\r\n  }, []);\r\n\r\n  const onTriggerKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLButtonElement>) => {\r\n      if (\r\n        REMOVE_SORT_SHORTCUTS.includes(event.key.toLowerCase()) &&\r\n        sorting.length > 0\r\n      ) {\r\n        event.preventDefault();\r\n        onSortingReset();\r\n      }\r\n    },\r\n    [sorting.length, onSortingReset],\r\n  );\r\n\r\n  return (\r\n    <Sortable\r\n      value={sorting}\r\n      onValueChange={onSortingChange}\r\n      getItemValue={(item) => item.id}\r\n    >\r\n      <Popover open={open} onOpenChange={setOpen}>\r\n        <PopoverTrigger asChild>\r\n          <Button\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            className=\"font-normal\"\r\n            onKeyDown={onTriggerKeyDown}\r\n          >\r\n            <ArrowDownUp className=\"text-muted-foreground\" />\r\n            Sort\r\n            {sorting.length > 0 && (\r\n              <Badge\r\n                variant=\"secondary\"\r\n                className=\"h-[18.24px] rounded-[3.2px] px-[5.12px] font-mono font-normal text-[10.4px]\"\r\n              >\r\n                {sorting.length}\r\n              </Badge>\r\n            )}\r\n          </Button>\r\n        </PopoverTrigger>\r\n        <PopoverContent\r\n          aria-labelledby={labelId}\r\n          aria-describedby={descriptionId}\r\n          className=\"flex w-full max-w-[var(--radix-popover-content-available-width)] origin-[var(--radix-popover-content-transform-origin)] flex-col gap-3.5 p-4 sm:min-w-[380px]\"\r\n          {...props}\r\n        >\r\n          <div className=\"flex flex-col gap-1\">\r\n            <h4 id={labelId} className=\"font-medium leading-none\">\r\n              {sorting.length > 0 ? \"Sort by\" : \"No sorting applied\"}\r\n            </h4>\r\n            <p\r\n              id={descriptionId}\r\n              className={cn(\r\n                \"text-muted-foreground text-sm\",\r\n                sorting.length > 0 && \"sr-only\",\r\n              )}\r\n            >\r\n              {sorting.length > 0\r\n                ? \"Modify sorting to organize your rows.\"\r\n                : \"Add sorting to organize your rows.\"}\r\n            </p>\r\n          </div>\r\n          {sorting.length > 0 && (\r\n            <SortableContent asChild>\r\n              <ul className=\"flex max-h-[300px] flex-col gap-2 overflow-y-auto p-1\">\r\n                {sorting.map((sort) => (\r\n                  <DataTableSortItem\r\n                    key={sort.id}\r\n                    sort={sort}\r\n                    sortItemId={`${id}-sort-${sort.id}`}\r\n                    columns={columns}\r\n                    columnLabels={columnLabels}\r\n                    onSortUpdate={onSortUpdate}\r\n                    onSortRemove={onSortRemove}\r\n                  />\r\n                ))}\r\n              </ul>\r\n            </SortableContent>\r\n          )}\r\n          <div className=\"flex w-full items-center gap-2\">\r\n            <Button\r\n              size=\"sm\"\r\n              className=\"rounded\"\r\n              ref={addButtonRef}\r\n              onClick={onSortAdd}\r\n              disabled={columns.length === 0}\r\n            >\r\n              Add sort\r\n            </Button>\r\n            {sorting.length > 0 && (\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                className=\"rounded\"\r\n                onClick={onSortingReset}\r\n              >\r\n                Reset sorting\r\n              </Button>\r\n            )}\r\n          </div>\r\n        </PopoverContent>\r\n      </Popover>\r\n      <SortableOverlay>\r\n        <div className=\"flex items-center gap-2\">\r\n          <div className=\"h-8 w-[180px] rounded-sm bg-primary/10\" />\r\n          <div className=\"h-8 w-24 rounded-sm bg-primary/10\" />\r\n          <div className=\"size-8 shrink-0 rounded-sm bg-primary/10\" />\r\n          <div className=\"size-8 shrink-0 rounded-sm bg-primary/10\" />\r\n        </div>\r\n      </SortableOverlay>\r\n    </Sortable>\r\n  );\r\n}\r\n\r\ninterface DataTableSortItemProps {\r\n  sort: ColumnSort;\r\n  sortItemId: string;\r\n  columns: { id: string; label: string }[];\r\n  columnLabels: Map<string, string>;\r\n  onSortUpdate: (sortId: string, updates: Partial<ColumnSort>) => void;\r\n  onSortRemove: (sortId: string) => void;\r\n}\r\n\r\nfunction DataTableSortItem({\r\n  sort,\r\n  sortItemId,\r\n  columns,\r\n  columnLabels,\r\n  onSortUpdate,\r\n  onSortRemove,\r\n}: DataTableSortItemProps) {\r\n  const fieldListboxId = `${sortItemId}-field-listbox`;\r\n  const fieldTriggerId = `${sortItemId}-field-trigger`;\r\n  const directionListboxId = `${sortItemId}-direction-listbox`;\r\n\r\n  const [showFieldSelector, setShowFieldSelector] = React.useState(false);\r\n  const [showDirectionSelector, setShowDirectionSelector] =\r\n    React.useState(false);\r\n\r\n  const onItemKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLLIElement>) => {\r\n      if (\r\n        event.target instanceof HTMLInputElement ||\r\n        event.target instanceof HTMLTextAreaElement\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (showFieldSelector || showDirectionSelector) {\r\n        return;\r\n      }\r\n\r\n      if (REMOVE_SORT_SHORTCUTS.includes(event.key.toLowerCase())) {\r\n        event.preventDefault();\r\n        onSortRemove(sort.id);\r\n      }\r\n    },\r\n    [sort.id, showFieldSelector, showDirectionSelector, onSortRemove],\r\n  );\r\n\r\n  return (\r\n    <SortableItem value={sort.id} asChild>\r\n      <li\r\n        id={sortItemId}\r\n        tabIndex={-1}\r\n        className=\"flex items-center gap-2\"\r\n        onKeyDown={onItemKeyDown}\r\n      >\r\n        <Popover open={showFieldSelector} onOpenChange={setShowFieldSelector}>\r\n          <PopoverTrigger asChild>\r\n            <Button\r\n              id={fieldTriggerId}\r\n              aria-controls={fieldListboxId}\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              className=\"w-44 justify-between rounded font-normal\"\r\n            >\r\n              <span className=\"truncate\">{columnLabels.get(sort.id)}</span>\r\n              <ChevronsUpDown className=\"opacity-50\" />\r\n            </Button>\r\n          </PopoverTrigger>\r\n          <PopoverContent\r\n            id={fieldListboxId}\r\n            className=\"w-[var(--radix-popover-trigger-width)] origin-[var(--radix-popover-content-transform-origin)] p-0\"\r\n          >\r\n            <Command>\r\n              <CommandInput placeholder=\"Search fields...\" />\r\n              <CommandList>\r\n                <CommandEmpty>No fields found.</CommandEmpty>\r\n                <CommandGroup>\r\n                  {columns.map((column) => (\r\n                    <CommandItem\r\n                      key={column.id}\r\n                      value={column.id}\r\n                      onSelect={(value) => onSortUpdate(sort.id, { id: value })}\r\n                    >\r\n                      <span className=\"truncate\">{column.label}</span>\r\n                    </CommandItem>\r\n                  ))}\r\n                </CommandGroup>\r\n              </CommandList>\r\n            </Command>\r\n          </PopoverContent>\r\n        </Popover>\r\n        <Select\r\n          open={showDirectionSelector}\r\n          onOpenChange={setShowDirectionSelector}\r\n          value={sort.desc ? \"desc\" : \"asc\"}\r\n          onValueChange={(value: SortDirection) =>\r\n            onSortUpdate(sort.id, { desc: value === \"desc\" })\r\n          }\r\n        >\r\n          <SelectTrigger\r\n            aria-controls={directionListboxId}\r\n            className=\"h-8 w-24 rounded [&[data-size]]:h-8\"\r\n          >\r\n            <SelectValue />\r\n          </SelectTrigger>\r\n          <SelectContent\r\n            id={directionListboxId}\r\n            className=\"min-w-[var(--radix-select-trigger-width)] origin-[var(--radix-select-content-transform-origin)]\"\r\n          >\r\n            {SORT_ORDERS.map((order) => (\r\n              <SelectItem key={order.value} value={order.value}>\r\n                {order.label}\r\n              </SelectItem>\r\n            ))}\r\n          </SelectContent>\r\n        </Select>\r\n        <Button\r\n          aria-controls={sortItemId}\r\n          variant=\"outline\"\r\n          size=\"icon\"\r\n          className=\"size-8 shrink-0 rounded\"\r\n          onClick={() => onSortRemove(sort.id)}\r\n        >\r\n          <Trash2 />\r\n        </Button>\r\n        <SortableItemHandle asChild>\r\n          <Button\r\n            variant=\"outline\"\r\n            size=\"icon\"\r\n            className=\"size-8 shrink-0 rounded\"\r\n          >\r\n            <GripVertical />\r\n          </Button>\r\n        </SortableItemHandle>\r\n      </li>\r\n    </SortableItem>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-grid/data-grid-sort-menu.tsx"
    },
    {
      "path": "src/components/ui/sortable.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  type Announcements,\r\n  closestCenter,\r\n  closestCorners,\r\n  DndContext,\r\n  type DndContextProps,\r\n  type DragEndEvent,\r\n  type DraggableAttributes,\r\n  type DraggableSyntheticListeners,\r\n  DragOverlay,\r\n  type DragStartEvent,\r\n  type DropAnimation,\r\n  defaultDropAnimationSideEffects,\r\n  KeyboardSensor,\r\n  MouseSensor,\r\n  type ScreenReaderInstructions,\r\n  TouchSensor,\r\n  type UniqueIdentifier,\r\n  useSensor,\r\n  useSensors,\r\n} from \"@dnd-kit/core\";\r\nimport {\r\n  restrictToHorizontalAxis,\r\n  restrictToParentElement,\r\n  restrictToVerticalAxis,\r\n} from \"@dnd-kit/modifiers\";\r\nimport {\r\n  arrayMove,\r\n  horizontalListSortingStrategy,\r\n  SortableContext,\r\n  type SortableContextProps,\r\n  sortableKeyboardCoordinates,\r\n  useSortable,\r\n  verticalListSortingStrategy,\r\n} from \"@dnd-kit/sortable\";\r\nimport { CSS } from \"@dnd-kit/utilities\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst orientationConfig = {\r\n  vertical: {\r\n    modifiers: [restrictToVerticalAxis, restrictToParentElement],\r\n    strategy: verticalListSortingStrategy,\r\n    collisionDetection: closestCenter,\r\n  },\r\n  horizontal: {\r\n    modifiers: [restrictToHorizontalAxis, restrictToParentElement],\r\n    strategy: horizontalListSortingStrategy,\r\n    collisionDetection: closestCenter,\r\n  },\r\n  mixed: {\r\n    modifiers: [restrictToParentElement],\r\n    strategy: undefined,\r\n    collisionDetection: closestCorners,\r\n  },\r\n};\r\n\r\nconst ROOT_NAME = \"Sortable\";\r\nconst CONTENT_NAME = \"SortableContent\";\r\nconst ITEM_NAME = \"SortableItem\";\r\nconst ITEM_HANDLE_NAME = \"SortableItemHandle\";\r\nconst OVERLAY_NAME = \"SortableOverlay\";\r\n\r\ninterface SortableRootContextValue<T> {\r\n  id: string;\r\n  items: UniqueIdentifier[];\r\n  modifiers: DndContextProps[\"modifiers\"];\r\n  strategy: SortableContextProps[\"strategy\"];\r\n  activeId: UniqueIdentifier | null;\r\n  setActiveId: (id: UniqueIdentifier | null) => void;\r\n  getItemValue: (item: T) => UniqueIdentifier;\r\n  flatCursor: boolean;\r\n}\r\n\r\nconst SortableRootContext =\r\n  React.createContext<SortableRootContextValue<unknown> | null>(null);\r\n\r\nfunction useSortableContext(consumerName: string) {\r\n  const context = React.useContext(SortableRootContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface GetItemValue<T> {\r\n  /**\r\n   * Callback that returns a unique identifier for each sortable item. Required for array of objects.\r\n   * @example getItemValue={(item) => item.id}\r\n   */\r\n  getItemValue: (item: T) => UniqueIdentifier;\r\n}\r\n\r\ntype SortableRootProps<T> = DndContextProps &\r\n  (T extends object ? GetItemValue<T> : Partial<GetItemValue<T>>) & {\r\n    value: T[];\r\n    onValueChange?: (items: T[]) => void;\r\n    onMove?: (\r\n      event: DragEndEvent & { activeIndex: number; overIndex: number },\r\n    ) => void;\r\n    strategy?: SortableContextProps[\"strategy\"];\r\n    orientation?: \"vertical\" | \"horizontal\" | \"mixed\";\r\n    flatCursor?: boolean;\r\n  };\r\n\r\nfunction SortableRoot<T>(props: SortableRootProps<T>) {\r\n  const {\r\n    value,\r\n    onValueChange,\r\n    collisionDetection,\r\n    modifiers,\r\n    strategy,\r\n    onMove,\r\n    orientation = \"vertical\",\r\n    flatCursor = false,\r\n    getItemValue: getItemValueProp,\r\n    accessibility,\r\n    onDragStart: onDragStartProp,\r\n    onDragEnd: onDragEndProp,\r\n    onDragCancel: onDragCancelProp,\r\n    ...sortableProps\r\n  } = props;\r\n\r\n  const id = React.useId();\r\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\r\n\r\n  const sensors = useSensors(\r\n    useSensor(MouseSensor),\r\n    useSensor(TouchSensor),\r\n    useSensor(KeyboardSensor, {\r\n      coordinateGetter: sortableKeyboardCoordinates,\r\n    }),\r\n  );\r\n  const config = React.useMemo(\r\n    () => orientationConfig[orientation],\r\n    [orientation],\r\n  );\r\n\r\n  const getItemValue = React.useCallback(\r\n    (item: T): UniqueIdentifier => {\r\n      if (typeof item === \"object\" && !getItemValueProp) {\r\n        throw new Error(\"getItemValue is required when using array of objects\");\r\n      }\r\n      return getItemValueProp\r\n        ? getItemValueProp(item)\r\n        : (item as UniqueIdentifier);\r\n    },\r\n    [getItemValueProp],\r\n  );\r\n\r\n  const items = React.useMemo(() => {\r\n    return value.map((item) => getItemValue(item));\r\n  }, [value, getItemValue]);\r\n\r\n  const onDragStart = React.useCallback(\r\n    (event: DragStartEvent) => {\r\n      onDragStartProp?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      setActiveId(event.active.id);\r\n    },\r\n    [onDragStartProp],\r\n  );\r\n\r\n  const onDragEnd = React.useCallback(\r\n    (event: DragEndEvent) => {\r\n      onDragEndProp?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      const { active, over } = event;\r\n      if (over && active.id !== over?.id) {\r\n        const activeIndex = value.findIndex(\r\n          (item) => getItemValue(item) === active.id,\r\n        );\r\n        const overIndex = value.findIndex(\r\n          (item) => getItemValue(item) === over.id,\r\n        );\r\n\r\n        if (onMove) {\r\n          onMove({ ...event, activeIndex, overIndex });\r\n        } else {\r\n          onValueChange?.(arrayMove(value, activeIndex, overIndex));\r\n        }\r\n      }\r\n      setActiveId(null);\r\n    },\r\n    [value, onValueChange, onMove, getItemValue, onDragEndProp],\r\n  );\r\n\r\n  const onDragCancel = React.useCallback(\r\n    (event: DragEndEvent) => {\r\n      onDragCancelProp?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      setActiveId(null);\r\n    },\r\n    [onDragCancelProp],\r\n  );\r\n\r\n  const announcements: Announcements = React.useMemo(\r\n    () => ({\r\n      onDragStart({ active }) {\r\n        const activeValue = active.id.toString();\r\n        return `Grabbed sortable item \"${activeValue}\". Current position is ${active.data.current?.sortable.index + 1} of ${value.length}. Use arrow keys to move, space to drop.`;\r\n      },\r\n      onDragOver({ active, over }) {\r\n        if (over) {\r\n          const overIndex = over.data.current?.sortable.index ?? 0;\r\n          const activeIndex = active.data.current?.sortable.index ?? 0;\r\n          const moveDirection = overIndex > activeIndex ? \"down\" : \"up\";\r\n          const activeValue = active.id.toString();\r\n          return `Sortable item \"${activeValue}\" moved ${moveDirection} to position ${overIndex + 1} of ${value.length}.`;\r\n        }\r\n        return \"Sortable item is no longer over a droppable area. Press escape to cancel.\";\r\n      },\r\n      onDragEnd({ active, over }) {\r\n        const activeValue = active.id.toString();\r\n        if (over) {\r\n          const overIndex = over.data.current?.sortable.index ?? 0;\r\n          return `Sortable item \"${activeValue}\" dropped at position ${overIndex + 1} of ${value.length}.`;\r\n        }\r\n        return `Sortable item \"${activeValue}\" dropped. No changes were made.`;\r\n      },\r\n      onDragCancel({ active }) {\r\n        const activeIndex = active.data.current?.sortable.index ?? 0;\r\n        const activeValue = active.id.toString();\r\n        return `Sorting cancelled. Sortable item \"${activeValue}\" returned to position ${activeIndex + 1} of ${value.length}.`;\r\n      },\r\n      onDragMove({ active, over }) {\r\n        if (over) {\r\n          const overIndex = over.data.current?.sortable.index ?? 0;\r\n          const activeIndex = active.data.current?.sortable.index ?? 0;\r\n          const moveDirection = overIndex > activeIndex ? \"down\" : \"up\";\r\n          const activeValue = active.id.toString();\r\n          return `Sortable item \"${activeValue}\" is moving ${moveDirection} to position ${overIndex + 1} of ${value.length}.`;\r\n        }\r\n        return \"Sortable item is no longer over a droppable area. Press escape to cancel.\";\r\n      },\r\n    }),\r\n    [value],\r\n  );\r\n\r\n  const screenReaderInstructions: ScreenReaderInstructions = React.useMemo(\r\n    () => ({\r\n      draggable: `\r\n        To pick up a sortable item, press space or enter.\r\n        While dragging, use the ${orientation === \"vertical\" ? \"up and down\" : orientation === \"horizontal\" ? \"left and right\" : \"arrow\"} keys to move the item.\r\n        Press space or enter again to drop the item in its new position, or press escape to cancel.\r\n      `,\r\n    }),\r\n    [orientation],\r\n  );\r\n\r\n  const contextValue = React.useMemo(\r\n    () => ({\r\n      id,\r\n      items,\r\n      modifiers: modifiers ?? config.modifiers,\r\n      strategy: strategy ?? config.strategy,\r\n      activeId,\r\n      setActiveId,\r\n      getItemValue,\r\n      flatCursor,\r\n    }),\r\n    [\r\n      id,\r\n      items,\r\n      modifiers,\r\n      strategy,\r\n      config.modifiers,\r\n      config.strategy,\r\n      activeId,\r\n      getItemValue,\r\n      flatCursor,\r\n    ],\r\n  );\r\n\r\n  return (\r\n    <SortableRootContext.Provider\r\n      value={contextValue as SortableRootContextValue<unknown>}\r\n    >\r\n      <DndContext\r\n        collisionDetection={collisionDetection ?? config.collisionDetection}\r\n        modifiers={modifiers ?? config.modifiers}\r\n        sensors={sensors}\r\n        {...sortableProps}\r\n        id={id}\r\n        onDragStart={onDragStart}\r\n        onDragEnd={onDragEnd}\r\n        onDragCancel={onDragCancel}\r\n        accessibility={{\r\n          announcements,\r\n          screenReaderInstructions,\r\n          ...accessibility,\r\n        }}\r\n      />\r\n    </SortableRootContext.Provider>\r\n  );\r\n}\r\n\r\nconst SortableContentContext = React.createContext<boolean>(false);\r\n\r\ninterface SortableContentProps extends React.ComponentProps<\"div\"> {\r\n  strategy?: SortableContextProps[\"strategy\"];\r\n  children: React.ReactNode;\r\n  asChild?: boolean;\r\n  withoutSlot?: boolean;\r\n}\r\n\r\nfunction SortableContent(props: SortableContentProps) {\r\n  const {\r\n    strategy: strategyProp,\r\n    asChild,\r\n    withoutSlot,\r\n    children,\r\n    ref,\r\n    ...contentProps\r\n  } = props;\r\n\r\n  const context = useSortableContext(CONTENT_NAME);\r\n\r\n  const ContentPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <SortableContentContext.Provider value={true}>\r\n      <SortableContext\r\n        items={context.items}\r\n        strategy={strategyProp ?? context.strategy}\r\n      >\r\n        {withoutSlot ? (\r\n          children\r\n        ) : (\r\n          <ContentPrimitive\r\n            data-slot=\"sortable-content\"\r\n            {...contentProps}\r\n            ref={ref}\r\n          >\r\n            {children}\r\n          </ContentPrimitive>\r\n        )}\r\n      </SortableContext>\r\n    </SortableContentContext.Provider>\r\n  );\r\n}\r\n\r\ninterface SortableItemContextValue {\r\n  id: string;\r\n  attributes: DraggableAttributes;\r\n  listeners: DraggableSyntheticListeners | undefined;\r\n  setActivatorNodeRef: (node: HTMLElement | null) => void;\r\n  isDragging?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst SortableItemContext =\r\n  React.createContext<SortableItemContextValue | null>(null);\r\n\r\nfunction useSortableItemContext(consumerName: string) {\r\n  const context = React.useContext(SortableItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface SortableItemProps extends React.ComponentProps<\"div\"> {\r\n  value: UniqueIdentifier;\r\n  asHandle?: boolean;\r\n  asChild?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nfunction SortableItem(props: SortableItemProps) {\r\n  const {\r\n    value,\r\n    style,\r\n    asHandle,\r\n    asChild,\r\n    disabled,\r\n    className,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const inSortableContent = React.useContext(SortableContentContext);\r\n  const inSortableOverlay = React.useContext(SortableOverlayContext);\r\n\r\n  if (!inSortableContent && !inSortableOverlay) {\r\n    throw new Error(\r\n      `\\`${ITEM_NAME}\\` must be used within \\`${CONTENT_NAME}\\` or \\`${OVERLAY_NAME}\\``,\r\n    );\r\n  }\r\n\r\n  if (value === \"\") {\r\n    throw new Error(`\\`${ITEM_NAME}\\` value cannot be an empty string`);\r\n  }\r\n\r\n  const context = useSortableContext(ITEM_NAME);\r\n  const id = React.useId();\r\n  const {\r\n    attributes,\r\n    listeners,\r\n    setNodeRef,\r\n    setActivatorNodeRef,\r\n    transform,\r\n    transition,\r\n    isDragging,\r\n  } = useSortable({ id: value, disabled });\r\n\r\n  const composedRef = useComposedRefs(ref, (node) => {\r\n    if (disabled) return;\r\n    setNodeRef(node);\r\n    if (asHandle) setActivatorNodeRef(node);\r\n  });\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      transform: CSS.Translate.toString(transform),\r\n      transition,\r\n      ...style,\r\n    };\r\n  }, [transform, transition, style]);\r\n\r\n  const itemContext = React.useMemo<SortableItemContextValue>(\r\n    () => ({\r\n      id,\r\n      attributes,\r\n      listeners,\r\n      setActivatorNodeRef,\r\n      isDragging,\r\n      disabled,\r\n    }),\r\n    [id, attributes, listeners, setActivatorNodeRef, isDragging, disabled],\r\n  );\r\n\r\n  const ItemPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <SortableItemContext.Provider value={itemContext}>\r\n      <ItemPrimitive\r\n        id={id}\r\n        data-disabled={disabled}\r\n        data-dragging={isDragging ? \"\" : undefined}\r\n        data-slot=\"sortable-item\"\r\n        {...itemProps}\r\n        {...(asHandle && !disabled ? attributes : {})}\r\n        {...(asHandle && !disabled ? listeners : {})}\r\n        ref={composedRef}\r\n        style={composedStyle}\r\n        className={cn(\r\n          \"focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1\",\r\n          {\r\n            \"touch-none select-none\": asHandle,\r\n            \"cursor-default\": context.flatCursor,\r\n            \"data-dragging:cursor-grabbing\": !context.flatCursor,\r\n            \"cursor-grab\": !isDragging && asHandle && !context.flatCursor,\r\n            \"opacity-50\": isDragging,\r\n            \"pointer-events-none opacity-50\": disabled,\r\n          },\r\n          className,\r\n        )}\r\n      />\r\n    </SortableItemContext.Provider>\r\n  );\r\n}\r\n\r\ninterface SortableItemHandleProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction SortableItemHandle(props: SortableItemHandleProps) {\r\n  const { asChild, disabled, className, ref, ...itemHandleProps } = props;\r\n\r\n  const context = useSortableContext(ITEM_HANDLE_NAME);\r\n  const itemContext = useSortableItemContext(ITEM_HANDLE_NAME);\r\n\r\n  const isDisabled = disabled ?? itemContext.disabled;\r\n\r\n  const composedRef = useComposedRefs(ref, (node) => {\r\n    if (!isDisabled) return;\r\n    itemContext.setActivatorNodeRef(node);\r\n  });\r\n\r\n  const HandlePrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <HandlePrimitive\r\n      type=\"button\"\r\n      aria-controls={itemContext.id}\r\n      data-disabled={isDisabled}\r\n      data-dragging={itemContext.isDragging ? \"\" : undefined}\r\n      data-slot=\"sortable-item-handle\"\r\n      {...itemHandleProps}\r\n      {...(isDisabled ? {} : itemContext.attributes)}\r\n      {...(isDisabled ? {} : itemContext.listeners)}\r\n      ref={composedRef}\r\n      className={cn(\r\n        \"select-none disabled:pointer-events-none disabled:opacity-50\",\r\n        context.flatCursor\r\n          ? \"cursor-default\"\r\n          : \"cursor-grab data-dragging:cursor-grabbing\",\r\n        className,\r\n      )}\r\n      disabled={isDisabled}\r\n    />\r\n  );\r\n}\r\n\r\nconst SortableOverlayContext = React.createContext(false);\r\n\r\nconst dropAnimation: DropAnimation = {\r\n  sideEffects: defaultDropAnimationSideEffects({\r\n    styles: {\r\n      active: {\r\n        opacity: \"0.4\",\r\n      },\r\n    },\r\n  }),\r\n};\r\n\r\ninterface SortableOverlayProps\r\n  extends Omit<React.ComponentProps<typeof DragOverlay>, \"children\"> {\r\n  container?: Element | DocumentFragment | null;\r\n  children?:\r\n    | ((params: { value: UniqueIdentifier }) => React.ReactNode)\r\n    | React.ReactNode;\r\n}\r\n\r\nfunction SortableOverlay(props: SortableOverlayProps) {\r\n  const { container: containerProp, children, ...overlayProps } = props;\r\n\r\n  const context = useSortableContext(OVERLAY_NAME);\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n  React.useLayoutEffect(() => setMounted(true), []);\r\n\r\n  const container =\r\n    containerProp ?? (mounted ? globalThis.document?.body : null);\r\n\r\n  if (!container) return null;\r\n\r\n  return ReactDOM.createPortal(\r\n    <DragOverlay\r\n      dropAnimation={dropAnimation}\r\n      modifiers={context.modifiers}\r\n      className={cn(!context.flatCursor && \"cursor-grabbing\")}\r\n      {...overlayProps}\r\n    >\r\n      <SortableOverlayContext.Provider value={true}>\r\n        {context.activeId\r\n          ? typeof children === \"function\"\r\n            ? children({ value: context.activeId })\r\n            : children\r\n          : null}\r\n      </SortableOverlayContext.Provider>\r\n    </DragOverlay>,\r\n    container,\r\n  );\r\n}\r\n\r\nexport {\r\n  SortableRoot as Sortable,\r\n  SortableContent,\r\n  SortableItem,\r\n  SortableItemHandle,\r\n  SortableOverlay,\r\n  //\r\n  SortableRoot as Root,\r\n  SortableContent as Content,\r\n  SortableItem as Item,\r\n  SortableItemHandle as ItemHandle,\r\n  SortableOverlay as Overlay,\r\n};\r\n",
      "type": "registry:ui",
      "target": "src/components/ui/sortable.tsx"
    },
    {
      "path": "src/lib/compose-refs.ts",
      "content": "/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\nimport * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we don't want to re-run this callback when the refs change\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib"
    }
  ]
}