{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-filter-list",
  "type": "registry:component",
  "title": "Data Table Filter List",
  "description": "A filter list component for the data table",
  "dependencies": [
    "@tanstack/react-table",
    "lucide-react",
    "nanoid",
    "nuqs"
  ],
  "registryDependencies": [
    "badge",
    "button",
    "calendar",
    "command",
    "input",
    "popover",
    "select"
  ],
  "files": [
    {
      "path": "src/components/data-table/data-table-filter-list.tsx",
      "content": "\"use client\";\r\n\r\nimport type { Column, ColumnMeta, Table } from \"@tanstack/react-table\";\r\nimport {\r\n  CalendarIcon,\r\n  Check,\r\n  ChevronsUpDown,\r\n  GripVertical,\r\n  ListFilter,\r\n  Trash2,\r\n} from \"lucide-react\";\r\nimport { parseAsStringEnum, useQueryState } from \"nuqs\";\r\nimport * as React from \"react\";\r\n\r\nimport { DataTableRangeFilter } from \"@/components/data-table/data-table-range-filter\";\r\nimport { Badge } from \"@/components/ui/badge\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Calendar } from \"@/components/ui/calendar\";\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from \"@/components/ui/command\";\r\nimport {\r\n  Faceted,\r\n  FacetedBadgeList,\r\n  FacetedContent,\r\n  FacetedEmpty,\r\n  FacetedGroup,\r\n  FacetedInput,\r\n  FacetedItem,\r\n  FacetedList,\r\n  FacetedTrigger,\r\n} from \"@/components/ui/faceted\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@/components/ui/popover\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from \"@/components/ui/select\";\r\nimport {\r\n  Sortable,\r\n  SortableContent,\r\n  SortableItem,\r\n  SortableItemHandle,\r\n  SortableOverlay,\r\n} from \"@/components/ui/sortable\";\r\nimport { dataTableConfig } from \"@/config/data-table\";\r\nimport { useDebouncedCallback } from \"@/hooks/use-debounced-callback\";\r\nimport { getDefaultFilterOperator, getFilterOperators } from \"@/lib/data-table\";\r\nimport { formatDate } from \"@/lib/format\";\r\nimport { generateId } from \"@/lib/id\";\r\nimport { getFiltersStateParser } from \"@/lib/parsers\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport type {\r\n  ExtendedColumnFilter,\r\n  FilterOperator,\r\n  JoinOperator,\r\n} from \"@/types/data-table\";\r\n\r\nconst DEBOUNCE_MS = 300;\r\nconst THROTTLE_MS = 50;\r\nconst FILTER_SHORTCUT_KEY = \"f\";\r\nconst REMOVE_FILTER_SHORTCUTS = [\"backspace\", \"delete\"];\r\n\r\ninterface DataTableFilterListProps<TData>\r\n  extends React.ComponentProps<typeof PopoverContent> {\r\n  table: Table<TData>;\r\n  debounceMs?: number;\r\n  throttleMs?: number;\r\n  shallow?: boolean;\r\n}\r\n\r\nexport function DataTableFilterList<TData>({\r\n  table,\r\n  debounceMs = DEBOUNCE_MS,\r\n  throttleMs = THROTTLE_MS,\r\n  shallow = true,\r\n  ...props\r\n}: DataTableFilterListProps<TData>) {\r\n  const id = React.useId();\r\n  const labelId = React.useId();\r\n  const descriptionId = React.useId();\r\n  const [open, setOpen] = React.useState(false);\r\n  const addButtonRef = React.useRef<HTMLButtonElement>(null);\r\n\r\n  const columns = React.useMemo(() => {\r\n    return table\r\n      .getAllColumns()\r\n      .filter((column) => column.columnDef.enableColumnFilter);\r\n  }, [table]);\r\n\r\n  const [filters, setFilters] = useQueryState(\r\n    table.options.meta?.queryKeys?.filters ?? \"filters\",\r\n    getFiltersStateParser<TData>(columns.map((field) => field.id))\r\n      .withDefault([])\r\n      .withOptions({\r\n        clearOnDefault: true,\r\n        shallow,\r\n        throttleMs,\r\n      }),\r\n  );\r\n  const debouncedSetFilters = useDebouncedCallback(setFilters, debounceMs);\r\n\r\n  const [joinOperator, setJoinOperator] = useQueryState(\r\n    table.options.meta?.queryKeys?.joinOperator ?? \"\",\r\n    parseAsStringEnum([\"and\", \"or\"]).withDefault(\"and\").withOptions({\r\n      clearOnDefault: true,\r\n      shallow,\r\n    }),\r\n  );\r\n\r\n  const onFilterAdd = React.useCallback(() => {\r\n    const column = columns[0];\r\n\r\n    if (!column) return;\r\n\r\n    debouncedSetFilters([\r\n      ...filters,\r\n      {\r\n        id: column.id as Extract<keyof TData, string>,\r\n        value: \"\",\r\n        variant: column.columnDef.meta?.variant ?? \"text\",\r\n        operator: getDefaultFilterOperator(\r\n          column.columnDef.meta?.variant ?? \"text\",\r\n        ),\r\n        filterId: generateId({ length: 8 }),\r\n      },\r\n    ]);\r\n  }, [columns, filters, debouncedSetFilters]);\r\n\r\n  const onFilterUpdate = React.useCallback(\r\n    (\r\n      filterId: string,\r\n      updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\r\n    ) => {\r\n      debouncedSetFilters((prevFilters) => {\r\n        const updatedFilters = prevFilters.map((filter) => {\r\n          if (filter.filterId === filterId) {\r\n            return { ...filter, ...updates } as ExtendedColumnFilter<TData>;\r\n          }\r\n          return filter;\r\n        });\r\n        return updatedFilters;\r\n      });\r\n    },\r\n    [debouncedSetFilters],\r\n  );\r\n\r\n  const onFilterRemove = React.useCallback(\r\n    (filterId: string) => {\r\n      const updatedFilters = filters.filter(\r\n        (filter) => filter.filterId !== filterId,\r\n      );\r\n      void setFilters(updatedFilters);\r\n      requestAnimationFrame(() => {\r\n        addButtonRef.current?.focus();\r\n      });\r\n    },\r\n    [filters, setFilters],\r\n  );\r\n\r\n  const onFiltersReset = React.useCallback(() => {\r\n    void setFilters(null);\r\n    void setJoinOperator(\"and\");\r\n  }, [setFilters, setJoinOperator]);\r\n\r\n  React.useEffect(() => {\r\n    function onKeyDown(event: KeyboardEvent) {\r\n      if (\r\n        event.target instanceof HTMLInputElement ||\r\n        event.target instanceof HTMLTextAreaElement ||\r\n        (event.target instanceof HTMLElement &&\r\n          event.target.contentEditable === \"true\")\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        event.key.toLowerCase() === FILTER_SHORTCUT_KEY &&\r\n        (event.ctrlKey || event.metaKey) &&\r\n        event.shiftKey\r\n      ) {\r\n        event.preventDefault();\r\n        setOpen((prev) => !prev);\r\n      }\r\n    }\r\n\r\n    window.addEventListener(\"keydown\", onKeyDown);\r\n    return () => window.removeEventListener(\"keydown\", onKeyDown);\r\n  }, []);\r\n\r\n  const onTriggerKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLButtonElement>) => {\r\n      if (\r\n        REMOVE_FILTER_SHORTCUTS.includes(event.key.toLowerCase()) &&\r\n        filters.length > 0\r\n      ) {\r\n        event.preventDefault();\r\n        onFilterRemove(filters[filters.length - 1]?.filterId ?? \"\");\r\n      }\r\n    },\r\n    [filters, onFilterRemove],\r\n  );\r\n\r\n  return (\r\n    <Sortable\r\n      value={filters}\r\n      onValueChange={setFilters}\r\n      getItemValue={(item) => item.filterId}\r\n    >\r\n      <Popover open={open} onOpenChange={setOpen}>\r\n        <PopoverTrigger asChild>\r\n          <Button\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            className=\"font-normal\"\r\n            onKeyDown={onTriggerKeyDown}\r\n          >\r\n            <ListFilter className=\"text-muted-foreground\" />\r\n            Filter\r\n            {filters.length > 0 && (\r\n              <Badge\r\n                variant=\"secondary\"\r\n                className=\"h-[18.24px] rounded-[3.2px] px-[5.12px] font-mono font-normal text-[10.4px]\"\r\n              >\r\n                {filters.length}\r\n              </Badge>\r\n            )}\r\n          </Button>\r\n        </PopoverTrigger>\r\n        <PopoverContent\r\n          aria-describedby={descriptionId}\r\n          aria-labelledby={labelId}\r\n          className=\"flex w-full max-w-[var(--radix-popover-content-available-width)] origin-[var(--radix-popover-content-transform-origin)] flex-col gap-3.5 p-4 sm:min-w-[380px]\"\r\n          {...props}\r\n        >\r\n          <div className=\"flex flex-col gap-1\">\r\n            <h4 id={labelId} className=\"font-medium leading-none\">\r\n              {filters.length > 0 ? \"Filters\" : \"No filters applied\"}\r\n            </h4>\r\n            <p\r\n              id={descriptionId}\r\n              className={cn(\r\n                \"text-muted-foreground text-sm\",\r\n                filters.length > 0 && \"sr-only\",\r\n              )}\r\n            >\r\n              {filters.length > 0\r\n                ? \"Modify filters to refine your rows.\"\r\n                : \"Add filters to refine your rows.\"}\r\n            </p>\r\n          </div>\r\n          {filters.length > 0 ? (\r\n            <SortableContent asChild>\r\n              <ul className=\"flex max-h-[300px] flex-col gap-2 overflow-y-auto p-1\">\r\n                {filters.map((filter, index) => (\r\n                  <DataTableFilterItem<TData>\r\n                    key={filter.filterId}\r\n                    filter={filter}\r\n                    index={index}\r\n                    filterItemId={`${id}-filter-${filter.filterId}`}\r\n                    joinOperator={joinOperator}\r\n                    setJoinOperator={setJoinOperator}\r\n                    columns={columns}\r\n                    onFilterUpdate={onFilterUpdate}\r\n                    onFilterRemove={onFilterRemove}\r\n                  />\r\n                ))}\r\n              </ul>\r\n            </SortableContent>\r\n          ) : null}\r\n          <div className=\"flex w-full items-center gap-2\">\r\n            <Button\r\n              size=\"sm\"\r\n              className=\"rounded\"\r\n              ref={addButtonRef}\r\n              onClick={onFilterAdd}\r\n            >\r\n              Add filter\r\n            </Button>\r\n            {filters.length > 0 ? (\r\n              <Button\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                className=\"rounded\"\r\n                onClick={onFiltersReset}\r\n              >\r\n                Reset filters\r\n              </Button>\r\n            ) : null}\r\n          </div>\r\n        </PopoverContent>\r\n      </Popover>\r\n      <SortableOverlay>\r\n        <div className=\"flex items-center gap-2\">\r\n          <div className=\"h-8 min-w-[72px] rounded-sm bg-primary/10\" />\r\n          <div className=\"h-8 w-32 rounded-sm bg-primary/10\" />\r\n          <div className=\"h-8 w-32 rounded-sm bg-primary/10\" />\r\n          <div className=\"h-8 min-w-36 flex-1 rounded-sm bg-primary/10\" />\r\n          <div className=\"size-8 shrink-0 rounded-sm bg-primary/10\" />\r\n          <div className=\"size-8 shrink-0 rounded-sm bg-primary/10\" />\r\n        </div>\r\n      </SortableOverlay>\r\n    </Sortable>\r\n  );\r\n}\r\n\r\ninterface DataTableFilterItemProps<TData> {\r\n  filter: ExtendedColumnFilter<TData>;\r\n  index: number;\r\n  filterItemId: string;\r\n  joinOperator: JoinOperator;\r\n  setJoinOperator: (value: JoinOperator) => void;\r\n  columns: Column<TData>[];\r\n  onFilterUpdate: (\r\n    filterId: string,\r\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\r\n  ) => void;\r\n  onFilterRemove: (filterId: string) => void;\r\n}\r\n\r\nfunction DataTableFilterItem<TData>({\r\n  filter,\r\n  index,\r\n  filterItemId,\r\n  joinOperator,\r\n  setJoinOperator,\r\n  columns,\r\n  onFilterUpdate,\r\n  onFilterRemove,\r\n}: DataTableFilterItemProps<TData>) {\r\n  const [showFieldSelector, setShowFieldSelector] = React.useState(false);\r\n  const [showOperatorSelector, setShowOperatorSelector] = React.useState(false);\r\n  const [showValueSelector, setShowValueSelector] = React.useState(false);\r\n\r\n  const column = columns.find((column) => column.id === filter.id);\r\n\r\n  const joinOperatorListboxId = `${filterItemId}-join-operator-listbox`;\r\n  const fieldListboxId = `${filterItemId}-field-listbox`;\r\n  const operatorListboxId = `${filterItemId}-operator-listbox`;\r\n  const inputId = `${filterItemId}-input`;\r\n\r\n  const columnMeta = column?.columnDef.meta;\r\n  const filterOperators = getFilterOperators(filter.variant);\r\n\r\n  const onItemKeyDown = React.useCallback(\r\n    (event: React.KeyboardEvent<HTMLLIElement>) => {\r\n      if (\r\n        event.target instanceof HTMLInputElement ||\r\n        event.target instanceof HTMLTextAreaElement\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (showFieldSelector || showOperatorSelector || showValueSelector) {\r\n        return;\r\n      }\r\n\r\n      if (REMOVE_FILTER_SHORTCUTS.includes(event.key.toLowerCase())) {\r\n        event.preventDefault();\r\n        onFilterRemove(filter.filterId);\r\n      }\r\n    },\r\n    [\r\n      filter.filterId,\r\n      showFieldSelector,\r\n      showOperatorSelector,\r\n      showValueSelector,\r\n      onFilterRemove,\r\n    ],\r\n  );\r\n\r\n  if (!column) return null;\r\n\r\n  return (\r\n    <SortableItem value={filter.filterId} asChild>\r\n      <li\r\n        id={filterItemId}\r\n        tabIndex={-1}\r\n        className=\"flex items-center gap-2\"\r\n        onKeyDown={onItemKeyDown}\r\n      >\r\n        <div className=\"min-w-[72px] text-center\">\r\n          {index === 0 ? (\r\n            <span className=\"text-muted-foreground text-sm\">Where</span>\r\n          ) : index === 1 ? (\r\n            <Select\r\n              value={joinOperator}\r\n              onValueChange={(value: JoinOperator) => setJoinOperator(value)}\r\n            >\r\n              <SelectTrigger\r\n                aria-label=\"Select join operator\"\r\n                aria-controls={joinOperatorListboxId}\r\n                className=\"h-8 rounded lowercase [&[data-size]]:h-8\"\r\n              >\r\n                <SelectValue placeholder={joinOperator} />\r\n              </SelectTrigger>\r\n              <SelectContent\r\n                id={joinOperatorListboxId}\r\n                position=\"popper\"\r\n                className=\"min-w-(--radix-select-trigger-width) lowercase\"\r\n              >\r\n                {dataTableConfig.joinOperators.map((joinOperator) => (\r\n                  <SelectItem key={joinOperator} value={joinOperator}>\r\n                    {joinOperator}\r\n                  </SelectItem>\r\n                ))}\r\n              </SelectContent>\r\n            </Select>\r\n          ) : (\r\n            <span className=\"text-muted-foreground text-sm\">\r\n              {joinOperator}\r\n            </span>\r\n          )}\r\n        </div>\r\n        <Popover open={showFieldSelector} onOpenChange={setShowFieldSelector}>\r\n          <PopoverTrigger asChild>\r\n            <Button\r\n              aria-controls={fieldListboxId}\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              className=\"w-32 justify-between rounded font-normal\"\r\n            >\r\n              <span className=\"truncate\">\r\n                {columns.find((column) => column.id === filter.id)?.columnDef\r\n                  .meta?.label ?? \"Select field\"}\r\n              </span>\r\n              <ChevronsUpDown className=\"opacity-50\" />\r\n            </Button>\r\n          </PopoverTrigger>\r\n          <PopoverContent\r\n            id={fieldListboxId}\r\n            align=\"start\"\r\n            className=\"w-40 origin-[var(--radix-popover-content-transform-origin)] p-0\"\r\n          >\r\n            <Command>\r\n              <CommandInput placeholder=\"Search fields...\" />\r\n              <CommandList>\r\n                <CommandEmpty>No fields found.</CommandEmpty>\r\n                <CommandGroup>\r\n                  {columns.map((column) => (\r\n                    <CommandItem\r\n                      key={column.id}\r\n                      value={column.id}\r\n                      onSelect={(value) => {\r\n                        onFilterUpdate(filter.filterId, {\r\n                          id: value as Extract<keyof TData, string>,\r\n                          variant: column.columnDef.meta?.variant ?? \"text\",\r\n                          operator: getDefaultFilterOperator(\r\n                            column.columnDef.meta?.variant ?? \"text\",\r\n                          ),\r\n                          value: \"\",\r\n                        });\r\n\r\n                        setShowFieldSelector(false);\r\n                      }}\r\n                    >\r\n                      <span className=\"truncate\">\r\n                        {column.columnDef.meta?.label}\r\n                      </span>\r\n                      <Check\r\n                        className={cn(\r\n                          \"ml-auto\",\r\n                          column.id === filter.id ? \"opacity-100\" : \"opacity-0\",\r\n                        )}\r\n                      />\r\n                    </CommandItem>\r\n                  ))}\r\n                </CommandGroup>\r\n              </CommandList>\r\n            </Command>\r\n          </PopoverContent>\r\n        </Popover>\r\n        <Select\r\n          open={showOperatorSelector}\r\n          onOpenChange={setShowOperatorSelector}\r\n          value={filter.operator}\r\n          onValueChange={(value: FilterOperator) =>\r\n            onFilterUpdate(filter.filterId, {\r\n              operator: value,\r\n              value:\r\n                value === \"isEmpty\" || value === \"isNotEmpty\"\r\n                  ? \"\"\r\n                  : filter.value,\r\n            })\r\n          }\r\n        >\r\n          <SelectTrigger\r\n            aria-controls={operatorListboxId}\r\n            className=\"h-8 w-32 rounded lowercase [&[data-size]]:h-8\"\r\n          >\r\n            <div className=\"truncate\">\r\n              <SelectValue placeholder={filter.operator} />\r\n            </div>\r\n          </SelectTrigger>\r\n          <SelectContent\r\n            id={operatorListboxId}\r\n            className=\"origin-[var(--radix-select-content-transform-origin)]\"\r\n          >\r\n            {filterOperators.map((operator) => (\r\n              <SelectItem\r\n                key={operator.value}\r\n                value={operator.value}\r\n                className=\"lowercase\"\r\n              >\r\n                {operator.label}\r\n              </SelectItem>\r\n            ))}\r\n          </SelectContent>\r\n        </Select>\r\n        <div className=\"min-w-36 flex-1\">\r\n          {onFilterInputRender({\r\n            filter,\r\n            inputId,\r\n            column,\r\n            columnMeta,\r\n            onFilterUpdate,\r\n            showValueSelector,\r\n            setShowValueSelector,\r\n          })}\r\n        </div>\r\n        <Button\r\n          aria-controls={filterItemId}\r\n          variant=\"outline\"\r\n          size=\"icon\"\r\n          className=\"size-8 rounded\"\r\n          onClick={() => onFilterRemove(filter.filterId)}\r\n        >\r\n          <Trash2 />\r\n        </Button>\r\n        <SortableItemHandle asChild>\r\n          <Button variant=\"outline\" size=\"icon\" className=\"size-8 rounded\">\r\n            <GripVertical />\r\n          </Button>\r\n        </SortableItemHandle>\r\n      </li>\r\n    </SortableItem>\r\n  );\r\n}\r\n\r\nfunction onFilterInputRender<TData>({\r\n  filter,\r\n  inputId,\r\n  column,\r\n  columnMeta,\r\n  onFilterUpdate,\r\n  showValueSelector,\r\n  setShowValueSelector,\r\n}: {\r\n  filter: ExtendedColumnFilter<TData>;\r\n  inputId: string;\r\n  column: Column<TData>;\r\n  columnMeta?: ColumnMeta<TData, unknown>;\r\n  onFilterUpdate: (\r\n    filterId: string,\r\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\r\n  ) => void;\r\n  showValueSelector: boolean;\r\n  setShowValueSelector: (value: boolean) => void;\r\n}) {\r\n  if (filter.operator === \"isEmpty\" || filter.operator === \"isNotEmpty\") {\r\n    return (\r\n      <div\r\n        id={inputId}\r\n        role=\"status\"\r\n        aria-label={`${columnMeta?.label} filter is ${\r\n          filter.operator === \"isEmpty\" ? \"empty\" : \"not empty\"\r\n        }`}\r\n        aria-live=\"polite\"\r\n        className=\"h-8 w-full rounded border bg-transparent dark:bg-input/30\"\r\n      />\r\n    );\r\n  }\r\n\r\n  switch (filter.variant) {\r\n    case \"text\":\r\n    case \"number\":\r\n    case \"range\": {\r\n      if (\r\n        (filter.variant === \"range\" && filter.operator === \"isBetween\") ||\r\n        filter.operator === \"isBetween\"\r\n      ) {\r\n        return (\r\n          <DataTableRangeFilter\r\n            filter={filter}\r\n            column={column}\r\n            inputId={inputId}\r\n            onFilterUpdate={onFilterUpdate}\r\n          />\r\n        );\r\n      }\r\n\r\n      const isNumber =\r\n        filter.variant === \"number\" || filter.variant === \"range\";\r\n\r\n      return (\r\n        <Input\r\n          id={inputId}\r\n          type={isNumber ? \"number\" : filter.variant}\r\n          aria-label={`${columnMeta?.label} filter value`}\r\n          aria-describedby={`${inputId}-description`}\r\n          inputMode={isNumber ? \"numeric\" : undefined}\r\n          placeholder={columnMeta?.placeholder ?? \"Enter a value...\"}\r\n          className=\"h-8 w-full rounded\"\r\n          defaultValue={\r\n            typeof filter.value === \"string\" ? filter.value : undefined\r\n          }\r\n          onChange={(event) =>\r\n            onFilterUpdate(filter.filterId, {\r\n              value: event.target.value,\r\n            })\r\n          }\r\n        />\r\n      );\r\n    }\r\n\r\n    case \"boolean\": {\r\n      if (Array.isArray(filter.value)) return null;\r\n\r\n      const inputListboxId = `${inputId}-listbox`;\r\n\r\n      return (\r\n        <Select\r\n          open={showValueSelector}\r\n          onOpenChange={setShowValueSelector}\r\n          value={filter.value}\r\n          onValueChange={(value) =>\r\n            onFilterUpdate(filter.filterId, {\r\n              value,\r\n            })\r\n          }\r\n        >\r\n          <SelectTrigger\r\n            id={inputId}\r\n            aria-controls={inputListboxId}\r\n            aria-label={`${columnMeta?.label} boolean filter`}\r\n            className=\"h-8 w-full rounded [&[data-size]]:h-8\"\r\n          >\r\n            <SelectValue placeholder={filter.value ? \"True\" : \"False\"} />\r\n          </SelectTrigger>\r\n          <SelectContent id={inputListboxId}>\r\n            <SelectItem value=\"true\">True</SelectItem>\r\n            <SelectItem value=\"false\">False</SelectItem>\r\n          </SelectContent>\r\n        </Select>\r\n      );\r\n    }\r\n\r\n    case \"select\":\r\n    case \"multiSelect\": {\r\n      const inputListboxId = `${inputId}-listbox`;\r\n\r\n      const multiple = filter.variant === \"multiSelect\";\r\n      const selectedValues = multiple\r\n        ? Array.isArray(filter.value)\r\n          ? filter.value\r\n          : []\r\n        : typeof filter.value === \"string\"\r\n          ? filter.value\r\n          : undefined;\r\n\r\n      return (\r\n        <Faceted\r\n          open={showValueSelector}\r\n          onOpenChange={setShowValueSelector}\r\n          value={selectedValues}\r\n          onValueChange={(value) => {\r\n            onFilterUpdate(filter.filterId, {\r\n              value,\r\n            });\r\n          }}\r\n          multiple={multiple}\r\n        >\r\n          <FacetedTrigger asChild>\r\n            <Button\r\n              id={inputId}\r\n              aria-controls={inputListboxId}\r\n              aria-label={`${columnMeta?.label} filter value${multiple ? \"s\" : \"\"}`}\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              className=\"w-full rounded font-normal\"\r\n            >\r\n              <FacetedBadgeList\r\n                options={columnMeta?.options}\r\n                placeholder={\r\n                  columnMeta?.placeholder ??\r\n                  `Select option${multiple ? \"s\" : \"\"}...`\r\n                }\r\n              />\r\n            </Button>\r\n          </FacetedTrigger>\r\n          <FacetedContent\r\n            id={inputListboxId}\r\n            className=\"w-[200px] origin-[var(--radix-popover-content-transform-origin)]\"\r\n          >\r\n            <FacetedInput\r\n              aria-label={`Search ${columnMeta?.label} options`}\r\n              placeholder={columnMeta?.placeholder ?? \"Search options...\"}\r\n            />\r\n            <FacetedList>\r\n              <FacetedEmpty>No options found.</FacetedEmpty>\r\n              <FacetedGroup>\r\n                {columnMeta?.options?.map((option) => (\r\n                  <FacetedItem key={option.value} value={option.value}>\r\n                    {option.icon && <option.icon />}\r\n                    <span>{option.label}</span>\r\n                    {option.count && (\r\n                      <span className=\"ml-auto font-mono text-xs\">\r\n                        {option.count}\r\n                      </span>\r\n                    )}\r\n                  </FacetedItem>\r\n                ))}\r\n              </FacetedGroup>\r\n            </FacetedList>\r\n          </FacetedContent>\r\n        </Faceted>\r\n      );\r\n    }\r\n\r\n    case \"date\":\r\n    case \"dateRange\": {\r\n      const inputListboxId = `${inputId}-listbox`;\r\n\r\n      const dateValue = Array.isArray(filter.value)\r\n        ? filter.value.filter(Boolean)\r\n        : [filter.value, filter.value].filter(Boolean);\r\n\r\n      const displayValue =\r\n        filter.operator === \"isBetween\" && dateValue.length === 2\r\n          ? `${formatDate(new Date(Number(dateValue[0])))} - ${formatDate(\r\n              new Date(Number(dateValue[1])),\r\n            )}`\r\n          : dateValue[0]\r\n            ? formatDate(new Date(Number(dateValue[0])))\r\n            : \"Pick a date\";\r\n\r\n      return (\r\n        <Popover open={showValueSelector} onOpenChange={setShowValueSelector}>\r\n          <PopoverTrigger asChild>\r\n            <Button\r\n              id={inputId}\r\n              aria-controls={inputListboxId}\r\n              aria-label={`${columnMeta?.label} date filter`}\r\n              variant=\"outline\"\r\n              size=\"sm\"\r\n              className={cn(\r\n                \"w-full justify-start rounded text-left font-normal\",\r\n                !filter.value && \"text-muted-foreground\",\r\n              )}\r\n            >\r\n              <CalendarIcon />\r\n              <span className=\"truncate\">{displayValue}</span>\r\n            </Button>\r\n          </PopoverTrigger>\r\n          <PopoverContent\r\n            id={inputListboxId}\r\n            align=\"start\"\r\n            className=\"w-auto origin-[var(--radix-popover-content-transform-origin)] p-0\"\r\n          >\r\n            {filter.operator === \"isBetween\" ? (\r\n              <Calendar\r\n                aria-label={`Select ${columnMeta?.label} date range`}\r\n                autoFocus\r\n                captionLayout=\"dropdown\"\r\n                mode=\"range\"\r\n                selected={\r\n                  dateValue.length === 2\r\n                    ? {\r\n                        from: new Date(Number(dateValue[0])),\r\n                        to: new Date(Number(dateValue[1])),\r\n                      }\r\n                    : {\r\n                        from: new Date(),\r\n                        to: new Date(),\r\n                      }\r\n                }\r\n                onSelect={(date) => {\r\n                  onFilterUpdate(filter.filterId, {\r\n                    value: date\r\n                      ? [\r\n                          (date.from?.getTime() ?? \"\").toString(),\r\n                          (date.to?.getTime() ?? \"\").toString(),\r\n                        ]\r\n                      : [],\r\n                  });\r\n                }}\r\n              />\r\n            ) : (\r\n              <Calendar\r\n                aria-label={`Select ${columnMeta?.label} date`}\r\n                autoFocus\r\n                captionLayout=\"dropdown\"\r\n                mode=\"single\"\r\n                selected={\r\n                  dateValue[0] ? new Date(Number(dateValue[0])) : undefined\r\n                }\r\n                onSelect={(date) => {\r\n                  onFilterUpdate(filter.filterId, {\r\n                    value: (date?.getTime() ?? \"\").toString(),\r\n                  });\r\n                }}\r\n              />\r\n            )}\r\n          </PopoverContent>\r\n        </Popover>\r\n      );\r\n    }\r\n\r\n    default:\r\n      return null;\r\n  }\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-table/data-table-filter-list.tsx"
    },
    {
      "path": "src/components/data-table/data-table-range-filter.tsx",
      "content": "\"use client\";\n\nimport type { Column } from \"@tanstack/react-table\";\nimport * as React from \"react\";\n\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\nimport type { ExtendedColumnFilter } from \"@/types/data-table\";\n\ninterface DataTableRangeFilterProps<TData> extends React.ComponentProps<\"div\"> {\n  filter: ExtendedColumnFilter<TData>;\n  column: Column<TData>;\n  inputId: string;\n  onFilterUpdate: (\n    filterId: string,\n    updates: Partial<Omit<ExtendedColumnFilter<TData>, \"filterId\">>,\n  ) => void;\n}\n\nexport function DataTableRangeFilter<TData>({\n  filter,\n  column,\n  inputId,\n  onFilterUpdate,\n  className,\n  ...props\n}: DataTableRangeFilterProps<TData>) {\n  const meta = column.columnDef.meta;\n\n  const [min, max] = React.useMemo(() => {\n    const range = column.columnDef.meta?.range;\n    if (range) return range;\n\n    const values = column.getFacetedMinMaxValues();\n    if (!values) return [0, 100];\n\n    return [values[0], values[1]];\n  }, [column]);\n\n  const formatValue = React.useCallback(\n    (value: string | number | undefined) => {\n      if (value === undefined || value === \"\") return \"\";\n      const numValue = Number(value);\n      return Number.isNaN(numValue)\n        ? \"\"\n        : numValue.toLocaleString(undefined, {\n            maximumFractionDigits: 0,\n          });\n    },\n    [],\n  );\n\n  const value = React.useMemo(() => {\n    if (Array.isArray(filter.value)) return filter.value.map(formatValue);\n    return [formatValue(filter.value), \"\"];\n  }, [filter.value, formatValue]);\n\n  const onRangeValueChange = React.useCallback(\n    (value: string, isMin?: boolean) => {\n      const numValue = Number(value);\n      const currentValues = Array.isArray(filter.value)\n        ? filter.value\n        : [\"\", \"\"];\n      const otherValue = isMin\n        ? (currentValues[1] ?? \"\")\n        : (currentValues[0] ?? \"\");\n\n      if (\n        value === \"\" ||\n        (!Number.isNaN(numValue) &&\n          (isMin\n            ? numValue >= min && numValue <= (Number(otherValue) || max)\n            : numValue <= max && numValue >= (Number(otherValue) || min)))\n      ) {\n        onFilterUpdate(filter.filterId, {\n          value: isMin ? [value, otherValue] : [otherValue, value],\n        });\n      }\n    },\n    [filter.filterId, filter.value, min, max, onFilterUpdate],\n  );\n\n  return (\n    <div\n      data-slot=\"range\"\n      className={cn(\"flex w-full items-center gap-2\", className)}\n      {...props}\n    >\n      <Input\n        id={`${inputId}-min`}\n        type=\"number\"\n        aria-label={`${meta?.label} minimum value`}\n        aria-valuemin={min}\n        aria-valuemax={max}\n        data-slot=\"range-min\"\n        inputMode=\"numeric\"\n        placeholder={min.toString()}\n        min={min}\n        max={max}\n        className=\"h-8 w-full rounded\"\n        defaultValue={value[0]}\n        onChange={(event) => onRangeValueChange(event.target.value, true)}\n      />\n      <span className=\"sr-only shrink-0 text-muted-foreground\">to</span>\n      <Input\n        id={`${inputId}-max`}\n        type=\"number\"\n        aria-label={`${meta?.label} maximum value`}\n        aria-valuemin={min}\n        aria-valuemax={max}\n        data-slot=\"range-max\"\n        inputMode=\"numeric\"\n        placeholder={max.toString()}\n        min={min}\n        max={max}\n        className=\"h-8 w-full rounded\"\n        defaultValue={value[1]}\n        onChange={(event) => onRangeValueChange(event.target.value)}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/components/data-table/data-table-range-filter.tsx"
    },
    {
      "path": "src/components/data-table/data-table-advanced-toolbar.tsx",
      "content": "\"use client\";\r\n\r\nimport type { Table } from \"@tanstack/react-table\";\r\nimport type * as React from \"react\";\r\n\r\nimport { DataTableViewOptions } from \"@/components/data-table/data-table-view-options\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ninterface DataTableAdvancedToolbarProps<TData>\r\n  extends React.ComponentProps<\"div\"> {\r\n  table: Table<TData>;\r\n}\r\n\r\nexport function DataTableAdvancedToolbar<TData>({\r\n  table,\r\n  children,\r\n  className,\r\n  ...props\r\n}: DataTableAdvancedToolbarProps<TData>) {\r\n  return (\r\n    <div\r\n      role=\"toolbar\"\r\n      aria-orientation=\"horizontal\"\r\n      className={cn(\r\n        \"flex w-full items-start justify-between gap-2 p-1\",\r\n        className,\r\n      )}\r\n      {...props}\r\n    >\r\n      <div className=\"flex flex-1 flex-wrap items-center gap-2\">{children}</div>\r\n      <div className=\"flex items-center gap-2\">\r\n        <DataTableViewOptions table={table} align=\"end\" />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component",
      "target": "src/components/data-table/data-table-advanced-toolbar.tsx"
    },
    {
      "path": "src/components/ui/sortable.tsx",
      "content": "\"use client\";\r\n\r\nimport {\r\n  type Announcements,\r\n  closestCenter,\r\n  closestCorners,\r\n  DndContext,\r\n  type DndContextProps,\r\n  type DragEndEvent,\r\n  type DraggableAttributes,\r\n  type DraggableSyntheticListeners,\r\n  DragOverlay,\r\n  type DragStartEvent,\r\n  type DropAnimation,\r\n  defaultDropAnimationSideEffects,\r\n  KeyboardSensor,\r\n  MouseSensor,\r\n  type ScreenReaderInstructions,\r\n  TouchSensor,\r\n  type UniqueIdentifier,\r\n  useSensor,\r\n  useSensors,\r\n} from \"@dnd-kit/core\";\r\nimport {\r\n  restrictToHorizontalAxis,\r\n  restrictToParentElement,\r\n  restrictToVerticalAxis,\r\n} from \"@dnd-kit/modifiers\";\r\nimport {\r\n  arrayMove,\r\n  horizontalListSortingStrategy,\r\n  SortableContext,\r\n  type SortableContextProps,\r\n  sortableKeyboardCoordinates,\r\n  useSortable,\r\n  verticalListSortingStrategy,\r\n} from \"@dnd-kit/sortable\";\r\nimport { CSS } from \"@dnd-kit/utilities\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst orientationConfig = {\r\n  vertical: {\r\n    modifiers: [restrictToVerticalAxis, restrictToParentElement],\r\n    strategy: verticalListSortingStrategy,\r\n    collisionDetection: closestCenter,\r\n  },\r\n  horizontal: {\r\n    modifiers: [restrictToHorizontalAxis, restrictToParentElement],\r\n    strategy: horizontalListSortingStrategy,\r\n    collisionDetection: closestCenter,\r\n  },\r\n  mixed: {\r\n    modifiers: [restrictToParentElement],\r\n    strategy: undefined,\r\n    collisionDetection: closestCorners,\r\n  },\r\n};\r\n\r\nconst ROOT_NAME = \"Sortable\";\r\nconst CONTENT_NAME = \"SortableContent\";\r\nconst ITEM_NAME = \"SortableItem\";\r\nconst ITEM_HANDLE_NAME = \"SortableItemHandle\";\r\nconst OVERLAY_NAME = \"SortableOverlay\";\r\n\r\ninterface SortableRootContextValue<T> {\r\n  id: string;\r\n  items: UniqueIdentifier[];\r\n  modifiers: DndContextProps[\"modifiers\"];\r\n  strategy: SortableContextProps[\"strategy\"];\r\n  activeId: UniqueIdentifier | null;\r\n  setActiveId: (id: UniqueIdentifier | null) => void;\r\n  getItemValue: (item: T) => UniqueIdentifier;\r\n  flatCursor: boolean;\r\n}\r\n\r\nconst SortableRootContext =\r\n  React.createContext<SortableRootContextValue<unknown> | null>(null);\r\n\r\nfunction useSortableContext(consumerName: string) {\r\n  const context = React.useContext(SortableRootContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface GetItemValue<T> {\r\n  /**\r\n   * Callback that returns a unique identifier for each sortable item. Required for array of objects.\r\n   * @example getItemValue={(item) => item.id}\r\n   */\r\n  getItemValue: (item: T) => UniqueIdentifier;\r\n}\r\n\r\ntype SortableRootProps<T> = DndContextProps &\r\n  (T extends object ? GetItemValue<T> : Partial<GetItemValue<T>>) & {\r\n    value: T[];\r\n    onValueChange?: (items: T[]) => void;\r\n    onMove?: (\r\n      event: DragEndEvent & { activeIndex: number; overIndex: number },\r\n    ) => void;\r\n    strategy?: SortableContextProps[\"strategy\"];\r\n    orientation?: \"vertical\" | \"horizontal\" | \"mixed\";\r\n    flatCursor?: boolean;\r\n  };\r\n\r\nfunction SortableRoot<T>(props: SortableRootProps<T>) {\r\n  const {\r\n    value,\r\n    onValueChange,\r\n    collisionDetection,\r\n    modifiers,\r\n    strategy,\r\n    onMove,\r\n    orientation = \"vertical\",\r\n    flatCursor = false,\r\n    getItemValue: getItemValueProp,\r\n    accessibility,\r\n    onDragStart: onDragStartProp,\r\n    onDragEnd: onDragEndProp,\r\n    onDragCancel: onDragCancelProp,\r\n    ...sortableProps\r\n  } = props;\r\n\r\n  const id = React.useId();\r\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\r\n\r\n  const sensors = useSensors(\r\n    useSensor(MouseSensor),\r\n    useSensor(TouchSensor),\r\n    useSensor(KeyboardSensor, {\r\n      coordinateGetter: sortableKeyboardCoordinates,\r\n    }),\r\n  );\r\n  const config = React.useMemo(\r\n    () => orientationConfig[orientation],\r\n    [orientation],\r\n  );\r\n\r\n  const getItemValue = React.useCallback(\r\n    (item: T): UniqueIdentifier => {\r\n      if (typeof item === \"object\" && !getItemValueProp) {\r\n        throw new Error(\"getItemValue is required when using array of objects\");\r\n      }\r\n      return getItemValueProp\r\n        ? getItemValueProp(item)\r\n        : (item as UniqueIdentifier);\r\n    },\r\n    [getItemValueProp],\r\n  );\r\n\r\n  const items = React.useMemo(() => {\r\n    return value.map((item) => getItemValue(item));\r\n  }, [value, getItemValue]);\r\n\r\n  const onDragStart = React.useCallback(\r\n    (event: DragStartEvent) => {\r\n      onDragStartProp?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      setActiveId(event.active.id);\r\n    },\r\n    [onDragStartProp],\r\n  );\r\n\r\n  const onDragEnd = React.useCallback(\r\n    (event: DragEndEvent) => {\r\n      onDragEndProp?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      const { active, over } = event;\r\n      if (over && active.id !== over?.id) {\r\n        const activeIndex = value.findIndex(\r\n          (item) => getItemValue(item) === active.id,\r\n        );\r\n        const overIndex = value.findIndex(\r\n          (item) => getItemValue(item) === over.id,\r\n        );\r\n\r\n        if (onMove) {\r\n          onMove({ ...event, activeIndex, overIndex });\r\n        } else {\r\n          onValueChange?.(arrayMove(value, activeIndex, overIndex));\r\n        }\r\n      }\r\n      setActiveId(null);\r\n    },\r\n    [value, onValueChange, onMove, getItemValue, onDragEndProp],\r\n  );\r\n\r\n  const onDragCancel = React.useCallback(\r\n    (event: DragEndEvent) => {\r\n      onDragCancelProp?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      setActiveId(null);\r\n    },\r\n    [onDragCancelProp],\r\n  );\r\n\r\n  const announcements: Announcements = React.useMemo(\r\n    () => ({\r\n      onDragStart({ active }) {\r\n        const activeValue = active.id.toString();\r\n        return `Grabbed sortable item \"${activeValue}\". Current position is ${active.data.current?.sortable.index + 1} of ${value.length}. Use arrow keys to move, space to drop.`;\r\n      },\r\n      onDragOver({ active, over }) {\r\n        if (over) {\r\n          const overIndex = over.data.current?.sortable.index ?? 0;\r\n          const activeIndex = active.data.current?.sortable.index ?? 0;\r\n          const moveDirection = overIndex > activeIndex ? \"down\" : \"up\";\r\n          const activeValue = active.id.toString();\r\n          return `Sortable item \"${activeValue}\" moved ${moveDirection} to position ${overIndex + 1} of ${value.length}.`;\r\n        }\r\n        return \"Sortable item is no longer over a droppable area. Press escape to cancel.\";\r\n      },\r\n      onDragEnd({ active, over }) {\r\n        const activeValue = active.id.toString();\r\n        if (over) {\r\n          const overIndex = over.data.current?.sortable.index ?? 0;\r\n          return `Sortable item \"${activeValue}\" dropped at position ${overIndex + 1} of ${value.length}.`;\r\n        }\r\n        return `Sortable item \"${activeValue}\" dropped. No changes were made.`;\r\n      },\r\n      onDragCancel({ active }) {\r\n        const activeIndex = active.data.current?.sortable.index ?? 0;\r\n        const activeValue = active.id.toString();\r\n        return `Sorting cancelled. Sortable item \"${activeValue}\" returned to position ${activeIndex + 1} of ${value.length}.`;\r\n      },\r\n      onDragMove({ active, over }) {\r\n        if (over) {\r\n          const overIndex = over.data.current?.sortable.index ?? 0;\r\n          const activeIndex = active.data.current?.sortable.index ?? 0;\r\n          const moveDirection = overIndex > activeIndex ? \"down\" : \"up\";\r\n          const activeValue = active.id.toString();\r\n          return `Sortable item \"${activeValue}\" is moving ${moveDirection} to position ${overIndex + 1} of ${value.length}.`;\r\n        }\r\n        return \"Sortable item is no longer over a droppable area. Press escape to cancel.\";\r\n      },\r\n    }),\r\n    [value],\r\n  );\r\n\r\n  const screenReaderInstructions: ScreenReaderInstructions = React.useMemo(\r\n    () => ({\r\n      draggable: `\r\n        To pick up a sortable item, press space or enter.\r\n        While dragging, use the ${orientation === \"vertical\" ? \"up and down\" : orientation === \"horizontal\" ? \"left and right\" : \"arrow\"} keys to move the item.\r\n        Press space or enter again to drop the item in its new position, or press escape to cancel.\r\n      `,\r\n    }),\r\n    [orientation],\r\n  );\r\n\r\n  const contextValue = React.useMemo(\r\n    () => ({\r\n      id,\r\n      items,\r\n      modifiers: modifiers ?? config.modifiers,\r\n      strategy: strategy ?? config.strategy,\r\n      activeId,\r\n      setActiveId,\r\n      getItemValue,\r\n      flatCursor,\r\n    }),\r\n    [\r\n      id,\r\n      items,\r\n      modifiers,\r\n      strategy,\r\n      config.modifiers,\r\n      config.strategy,\r\n      activeId,\r\n      getItemValue,\r\n      flatCursor,\r\n    ],\r\n  );\r\n\r\n  return (\r\n    <SortableRootContext.Provider\r\n      value={contextValue as SortableRootContextValue<unknown>}\r\n    >\r\n      <DndContext\r\n        collisionDetection={collisionDetection ?? config.collisionDetection}\r\n        modifiers={modifiers ?? config.modifiers}\r\n        sensors={sensors}\r\n        {...sortableProps}\r\n        id={id}\r\n        onDragStart={onDragStart}\r\n        onDragEnd={onDragEnd}\r\n        onDragCancel={onDragCancel}\r\n        accessibility={{\r\n          announcements,\r\n          screenReaderInstructions,\r\n          ...accessibility,\r\n        }}\r\n      />\r\n    </SortableRootContext.Provider>\r\n  );\r\n}\r\n\r\nconst SortableContentContext = React.createContext<boolean>(false);\r\n\r\ninterface SortableContentProps extends React.ComponentProps<\"div\"> {\r\n  strategy?: SortableContextProps[\"strategy\"];\r\n  children: React.ReactNode;\r\n  asChild?: boolean;\r\n  withoutSlot?: boolean;\r\n}\r\n\r\nfunction SortableContent(props: SortableContentProps) {\r\n  const {\r\n    strategy: strategyProp,\r\n    asChild,\r\n    withoutSlot,\r\n    children,\r\n    ref,\r\n    ...contentProps\r\n  } = props;\r\n\r\n  const context = useSortableContext(CONTENT_NAME);\r\n\r\n  const ContentPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <SortableContentContext.Provider value={true}>\r\n      <SortableContext\r\n        items={context.items}\r\n        strategy={strategyProp ?? context.strategy}\r\n      >\r\n        {withoutSlot ? (\r\n          children\r\n        ) : (\r\n          <ContentPrimitive\r\n            data-slot=\"sortable-content\"\r\n            {...contentProps}\r\n            ref={ref}\r\n          >\r\n            {children}\r\n          </ContentPrimitive>\r\n        )}\r\n      </SortableContext>\r\n    </SortableContentContext.Provider>\r\n  );\r\n}\r\n\r\ninterface SortableItemContextValue {\r\n  id: string;\r\n  attributes: DraggableAttributes;\r\n  listeners: DraggableSyntheticListeners | undefined;\r\n  setActivatorNodeRef: (node: HTMLElement | null) => void;\r\n  isDragging?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst SortableItemContext =\r\n  React.createContext<SortableItemContextValue | null>(null);\r\n\r\nfunction useSortableItemContext(consumerName: string) {\r\n  const context = React.useContext(SortableItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface SortableItemProps extends React.ComponentProps<\"div\"> {\r\n  value: UniqueIdentifier;\r\n  asHandle?: boolean;\r\n  asChild?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nfunction SortableItem(props: SortableItemProps) {\r\n  const {\r\n    value,\r\n    style,\r\n    asHandle,\r\n    asChild,\r\n    disabled,\r\n    className,\r\n    ref,\r\n    ...itemProps\r\n  } = props;\r\n\r\n  const inSortableContent = React.useContext(SortableContentContext);\r\n  const inSortableOverlay = React.useContext(SortableOverlayContext);\r\n\r\n  if (!inSortableContent && !inSortableOverlay) {\r\n    throw new Error(\r\n      `\\`${ITEM_NAME}\\` must be used within \\`${CONTENT_NAME}\\` or \\`${OVERLAY_NAME}\\``,\r\n    );\r\n  }\r\n\r\n  if (value === \"\") {\r\n    throw new Error(`\\`${ITEM_NAME}\\` value cannot be an empty string`);\r\n  }\r\n\r\n  const context = useSortableContext(ITEM_NAME);\r\n  const id = React.useId();\r\n  const {\r\n    attributes,\r\n    listeners,\r\n    setNodeRef,\r\n    setActivatorNodeRef,\r\n    transform,\r\n    transition,\r\n    isDragging,\r\n  } = useSortable({ id: value, disabled });\r\n\r\n  const composedRef = useComposedRefs(ref, (node) => {\r\n    if (disabled) return;\r\n    setNodeRef(node);\r\n    if (asHandle) setActivatorNodeRef(node);\r\n  });\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      transform: CSS.Translate.toString(transform),\r\n      transition,\r\n      ...style,\r\n    };\r\n  }, [transform, transition, style]);\r\n\r\n  const itemContext = React.useMemo<SortableItemContextValue>(\r\n    () => ({\r\n      id,\r\n      attributes,\r\n      listeners,\r\n      setActivatorNodeRef,\r\n      isDragging,\r\n      disabled,\r\n    }),\r\n    [id, attributes, listeners, setActivatorNodeRef, isDragging, disabled],\r\n  );\r\n\r\n  const ItemPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <SortableItemContext.Provider value={itemContext}>\r\n      <ItemPrimitive\r\n        id={id}\r\n        data-disabled={disabled}\r\n        data-dragging={isDragging ? \"\" : undefined}\r\n        data-slot=\"sortable-item\"\r\n        {...itemProps}\r\n        {...(asHandle && !disabled ? attributes : {})}\r\n        {...(asHandle && !disabled ? listeners : {})}\r\n        ref={composedRef}\r\n        style={composedStyle}\r\n        className={cn(\r\n          \"focus-visible:outline-hidden focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1\",\r\n          {\r\n            \"touch-none select-none\": asHandle,\r\n            \"cursor-default\": context.flatCursor,\r\n            \"data-dragging:cursor-grabbing\": !context.flatCursor,\r\n            \"cursor-grab\": !isDragging && asHandle && !context.flatCursor,\r\n            \"opacity-50\": isDragging,\r\n            \"pointer-events-none opacity-50\": disabled,\r\n          },\r\n          className,\r\n        )}\r\n      />\r\n    </SortableItemContext.Provider>\r\n  );\r\n}\r\n\r\ninterface SortableItemHandleProps extends React.ComponentProps<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nfunction SortableItemHandle(props: SortableItemHandleProps) {\r\n  const { asChild, disabled, className, ref, ...itemHandleProps } = props;\r\n\r\n  const context = useSortableContext(ITEM_HANDLE_NAME);\r\n  const itemContext = useSortableItemContext(ITEM_HANDLE_NAME);\r\n\r\n  const isDisabled = disabled ?? itemContext.disabled;\r\n\r\n  const composedRef = useComposedRefs(ref, (node) => {\r\n    if (!isDisabled) return;\r\n    itemContext.setActivatorNodeRef(node);\r\n  });\r\n\r\n  const HandlePrimitive = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <HandlePrimitive\r\n      type=\"button\"\r\n      aria-controls={itemContext.id}\r\n      data-disabled={isDisabled}\r\n      data-dragging={itemContext.isDragging ? \"\" : undefined}\r\n      data-slot=\"sortable-item-handle\"\r\n      {...itemHandleProps}\r\n      {...(isDisabled ? {} : itemContext.attributes)}\r\n      {...(isDisabled ? {} : itemContext.listeners)}\r\n      ref={composedRef}\r\n      className={cn(\r\n        \"select-none disabled:pointer-events-none disabled:opacity-50\",\r\n        context.flatCursor\r\n          ? \"cursor-default\"\r\n          : \"cursor-grab data-dragging:cursor-grabbing\",\r\n        className,\r\n      )}\r\n      disabled={isDisabled}\r\n    />\r\n  );\r\n}\r\n\r\nconst SortableOverlayContext = React.createContext(false);\r\n\r\nconst dropAnimation: DropAnimation = {\r\n  sideEffects: defaultDropAnimationSideEffects({\r\n    styles: {\r\n      active: {\r\n        opacity: \"0.4\",\r\n      },\r\n    },\r\n  }),\r\n};\r\n\r\ninterface SortableOverlayProps\r\n  extends Omit<React.ComponentProps<typeof DragOverlay>, \"children\"> {\r\n  container?: Element | DocumentFragment | null;\r\n  children?:\r\n    | ((params: { value: UniqueIdentifier }) => React.ReactNode)\r\n    | React.ReactNode;\r\n}\r\n\r\nfunction SortableOverlay(props: SortableOverlayProps) {\r\n  const { container: containerProp, children, ...overlayProps } = props;\r\n\r\n  const context = useSortableContext(OVERLAY_NAME);\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n  React.useLayoutEffect(() => setMounted(true), []);\r\n\r\n  const container =\r\n    containerProp ?? (mounted ? globalThis.document?.body : null);\r\n\r\n  if (!container) return null;\r\n\r\n  return ReactDOM.createPortal(\r\n    <DragOverlay\r\n      dropAnimation={dropAnimation}\r\n      modifiers={context.modifiers}\r\n      className={cn(!context.flatCursor && \"cursor-grabbing\")}\r\n      {...overlayProps}\r\n    >\r\n      <SortableOverlayContext.Provider value={true}>\r\n        {context.activeId\r\n          ? typeof children === \"function\"\r\n            ? children({ value: context.activeId })\r\n            : children\r\n          : null}\r\n      </SortableOverlayContext.Provider>\r\n    </DragOverlay>,\r\n    container,\r\n  );\r\n}\r\n\r\nexport {\r\n  SortableRoot as Sortable,\r\n  SortableContent,\r\n  SortableItem,\r\n  SortableItemHandle,\r\n  SortableOverlay,\r\n  //\r\n  SortableRoot as Root,\r\n  SortableContent as Content,\r\n  SortableItem as Item,\r\n  SortableItemHandle as ItemHandle,\r\n  SortableOverlay as Overlay,\r\n};\r\n",
      "type": "registry:ui",
      "target": "src/components/ui/sortable.tsx"
    },
    {
      "path": "src/components/ui/faceted.tsx",
      "content": "\"use client\";\r\n\r\nimport { Check, ChevronsUpDown } from \"lucide-react\";\r\nimport * as React from \"react\";\r\n\r\nimport { Badge } from \"@/components/ui/badge\";\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n  CommandSeparator,\r\n} from \"@/components/ui/command\";\r\nimport {\r\n  Popover,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from \"@/components/ui/popover\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ntype FacetedValue<Multiple extends boolean> = Multiple extends true\r\n  ? string[]\r\n  : string;\r\n\r\ninterface FacetedContextValue<Multiple extends boolean = boolean> {\r\n  value?: FacetedValue<Multiple>;\r\n  onItemSelect?: (value: string) => void;\r\n  multiple?: Multiple;\r\n}\r\n\r\nconst FacetedContext = React.createContext<FacetedContextValue<boolean> | null>(\r\n  null,\r\n);\r\n\r\nfunction useFacetedContext(name: string) {\r\n  const context = React.useContext(FacetedContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${name}\\` must be within Faceted`);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface FacetedProps<Multiple extends boolean = false>\r\n  extends React.ComponentProps<typeof Popover> {\r\n  value?: FacetedValue<Multiple>;\r\n  onValueChange?: (value: FacetedValue<Multiple> | undefined) => void;\r\n  children?: React.ReactNode;\r\n  multiple?: Multiple;\r\n}\r\n\r\nfunction Faceted<Multiple extends boolean = false>(\r\n  props: FacetedProps<Multiple>,\r\n) {\r\n  const {\r\n    open: openProp,\r\n    onOpenChange: onOpenChangeProp,\r\n    value,\r\n    onValueChange,\r\n    children,\r\n    multiple = false,\r\n    ...facetedProps\r\n  } = props;\r\n\r\n  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false);\r\n  const isControlled = openProp !== undefined;\r\n  const open = isControlled ? openProp : uncontrolledOpen;\r\n\r\n  const onOpenChange = React.useCallback(\r\n    (newOpen: boolean) => {\r\n      if (!isControlled) {\r\n        setUncontrolledOpen(newOpen);\r\n      }\r\n      onOpenChangeProp?.(newOpen);\r\n    },\r\n    [isControlled, onOpenChangeProp],\r\n  );\r\n\r\n  const onItemSelect = React.useCallback(\r\n    (selectedValue: string) => {\r\n      if (!onValueChange) return;\r\n\r\n      if (multiple) {\r\n        const currentValue = (Array.isArray(value) ? value : []) as string[];\r\n        const newValue = currentValue.includes(selectedValue)\r\n          ? currentValue.filter((v) => v !== selectedValue)\r\n          : [...currentValue, selectedValue];\r\n        onValueChange(newValue as FacetedValue<Multiple>);\r\n      } else {\r\n        if (value === selectedValue) {\r\n          onValueChange(undefined);\r\n        } else {\r\n          onValueChange(selectedValue as FacetedValue<Multiple>);\r\n        }\r\n\r\n        requestAnimationFrame(() => onOpenChange(false));\r\n      }\r\n    },\r\n    [multiple, value, onValueChange, onOpenChange],\r\n  );\r\n\r\n  const contextValue = React.useMemo<FacetedContextValue<typeof multiple>>(\r\n    () => ({ value, onItemSelect, multiple }),\r\n    [value, onItemSelect, multiple],\r\n  );\r\n\r\n  return (\r\n    <FacetedContext.Provider value={contextValue}>\r\n      <Popover open={open} onOpenChange={onOpenChange} {...facetedProps}>\r\n        {children}\r\n      </Popover>\r\n    </FacetedContext.Provider>\r\n  );\r\n}\r\n\r\nfunction FacetedTrigger(props: React.ComponentProps<typeof PopoverTrigger>) {\r\n  const { className, children, ...triggerProps } = props;\r\n\r\n  return (\r\n    <PopoverTrigger\r\n      {...triggerProps}\r\n      className={cn(\"justify-between text-left\", className)}\r\n    >\r\n      {children}\r\n    </PopoverTrigger>\r\n  );\r\n}\r\n\r\ninterface FacetedBadgeListProps extends React.ComponentProps<\"div\"> {\r\n  options?: { label: string; value: string }[];\r\n  max?: number;\r\n  badgeClassName?: string;\r\n  placeholder?: string;\r\n}\r\n\r\nfunction FacetedBadgeList(props: FacetedBadgeListProps) {\r\n  const {\r\n    options = [],\r\n    max = 2,\r\n    placeholder = \"Select options...\",\r\n    className,\r\n    badgeClassName,\r\n    ...badgeListProps\r\n  } = props;\r\n\r\n  const context = useFacetedContext(\"FacetedBadgeList\");\r\n  const values = Array.isArray(context.value)\r\n    ? context.value\r\n    : ([context.value].filter(Boolean) as string[]);\r\n\r\n  const getLabel = React.useCallback(\r\n    (value: string) => {\r\n      const option = options.find((opt) => opt.value === value);\r\n      return option?.label ?? value;\r\n    },\r\n    [options],\r\n  );\r\n\r\n  if (!values || values.length === 0) {\r\n    return (\r\n      <div\r\n        {...badgeListProps}\r\n        className=\"flex w-full items-center gap-1 text-muted-foreground\"\r\n      >\r\n        {placeholder}\r\n        <ChevronsUpDown className=\"ml-auto size-4 shrink-0 opacity-50\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div\r\n      {...badgeListProps}\r\n      className={cn(\"flex flex-wrap items-center gap-1\", className)}\r\n    >\r\n      {values.length > max ? (\r\n        <Badge\r\n          variant=\"secondary\"\r\n          className={cn(\"rounded-sm px-1 font-normal\", badgeClassName)}\r\n        >\r\n          {values.length} selected\r\n        </Badge>\r\n      ) : (\r\n        values.map((value) => (\r\n          <Badge\r\n            key={value}\r\n            variant=\"secondary\"\r\n            className={cn(\"rounded-sm px-1 font-normal\", badgeClassName)}\r\n          >\r\n            <span className=\"truncate\">{getLabel(value)}</span>\r\n          </Badge>\r\n        ))\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction FacetedContent(props: React.ComponentProps<typeof PopoverContent>) {\r\n  const { className, children, ...contentProps } = props;\r\n\r\n  return (\r\n    <PopoverContent\r\n      {...contentProps}\r\n      align=\"start\"\r\n      className={cn(\r\n        \"w-[200px] origin-(--radix-popover-content-transform-origin) p-0\",\r\n        className,\r\n      )}\r\n    >\r\n      <Command>{children}</Command>\r\n    </PopoverContent>\r\n  );\r\n}\r\n\r\nconst FacetedInput = CommandInput;\r\n\r\nconst FacetedList = CommandList;\r\n\r\nconst FacetedEmpty = CommandEmpty;\r\n\r\nconst FacetedGroup = CommandGroup;\r\n\r\ninterface FacetedItemProps extends React.ComponentProps<typeof CommandItem> {\r\n  value: string;\r\n}\r\n\r\nfunction FacetedItem(props: FacetedItemProps) {\r\n  const { value, onSelect, className, children, ...itemProps } = props;\r\n  const context = useFacetedContext(\"FacetedItem\");\r\n\r\n  const isSelected = context.multiple\r\n    ? Array.isArray(context.value) && context.value.includes(value)\r\n    : context.value === value;\r\n\r\n  const onItemSelect = React.useCallback(\r\n    (currentValue: string) => {\r\n      if (onSelect) {\r\n        onSelect(currentValue);\r\n      } else if (context.onItemSelect) {\r\n        context.onItemSelect(currentValue);\r\n      }\r\n    },\r\n    [onSelect, context],\r\n  );\r\n\r\n  return (\r\n    <CommandItem\r\n      aria-selected={isSelected}\r\n      data-selected={isSelected}\r\n      className={cn(\"gap-2\", className)}\r\n      onSelect={() => onItemSelect(value)}\r\n      {...itemProps}\r\n    >\r\n      <span\r\n        className={cn(\r\n          \"flex size-4 items-center justify-center rounded-sm border border-primary\",\r\n          isSelected\r\n            ? \"bg-primary text-primary-foreground\"\r\n            : \"opacity-50 [&_svg]:invisible\",\r\n        )}\r\n      >\r\n        <Check className=\"size-4\" />\r\n      </span>\r\n      {children}\r\n    </CommandItem>\r\n  );\r\n}\r\n\r\nconst FacetedSeparator = CommandSeparator;\r\n\r\nexport {\r\n  Faceted,\r\n  FacetedBadgeList,\r\n  FacetedContent,\r\n  FacetedEmpty,\r\n  FacetedGroup,\r\n  FacetedInput,\r\n  FacetedItem,\r\n  FacetedList,\r\n  FacetedSeparator,\r\n  FacetedTrigger,\r\n};\r\n",
      "type": "registry:ui",
      "target": "src/components/ui/faceted.tsx"
    },
    {
      "path": "src/hooks/use-callback-ref.ts",
      "content": "import * as React from \"react\";\n\n/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/use-callback-ref/src/useCallbackRef.tsx\n */\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: never[]) => unknown>(\n  callback: T | undefined,\n): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(\n    () => ((...args) => callbackRef.current?.(...args)) as T,\n    [],\n  );\n}\n\nexport { useCallbackRef };\n",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/use-debounced-callback.ts",
      "content": "/**\n * @see https://github.com/mantinedev/mantine/blob/master/packages/@mantine/hooks/src/use-debounced-callback/use-debounced-callback.ts\n */\n\nimport * as React from \"react\";\n\nimport { useCallbackRef } from \"@/hooks/use-callback-ref\";\n\nexport function useDebouncedCallback<T extends (...args: never[]) => unknown>(\n  callback: T,\n  delay: number,\n) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = React.useRef(0);\n  React.useEffect(\n    () => () => window.clearTimeout(debounceTimerRef.current),\n    [],\n  );\n\n  const setValue = React.useCallback(\n    (...args: Parameters<T>) => {\n      window.clearTimeout(debounceTimerRef.current);\n      debounceTimerRef.current = window.setTimeout(\n        () => handleCallback(...args),\n        delay,\n      );\n    },\n    [handleCallback, delay],\n  );\n\n  return setValue;\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "src/lib/compose-refs.ts",
      "content": "/**\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n\nimport * as React from \"react\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  }\n\n  if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we don't want to re-run this callback when the refs change\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/data-table.ts",
      "content": "import type { Column } from \"@tanstack/react-table\";\r\nimport { dataTableConfig } from \"@/config/data-table\";\r\nimport type {\r\n  ExtendedColumnFilter,\r\n  FilterOperator,\r\n  FilterVariant,\r\n} from \"@/types/data-table\";\r\n\r\nexport function getCommonPinningStyles<TData>({\r\n  column,\r\n  withBorder = false,\r\n}: {\r\n  column: Column<TData>;\r\n  withBorder?: boolean;\r\n}): React.CSSProperties {\r\n  const isPinned = column.getIsPinned();\r\n  const isLastLeftPinnedColumn =\r\n    isPinned === \"left\" && column.getIsLastColumn(\"left\");\r\n  const isFirstRightPinnedColumn =\r\n    isPinned === \"right\" && column.getIsFirstColumn(\"right\");\r\n\r\n  return {\r\n    boxShadow: withBorder\r\n      ? isLastLeftPinnedColumn\r\n        ? \"-4px 0 4px -4px var(--border) inset\"\r\n        : isFirstRightPinnedColumn\r\n          ? \"4px 0 4px -4px var(--border) inset\"\r\n          : undefined\r\n      : undefined,\r\n    left: isPinned === \"left\" ? `${column.getStart(\"left\")}px` : undefined,\r\n    right: isPinned === \"right\" ? `${column.getAfter(\"right\")}px` : undefined,\r\n    opacity: isPinned ? 0.97 : 1,\r\n    position: isPinned ? \"sticky\" : \"relative\",\r\n    background: isPinned ? \"var(--background)\" : \"var(--background)\",\r\n    width: column.getSize(),\r\n    zIndex: isPinned ? 1 : undefined,\r\n  };\r\n}\r\n\r\nexport function getFilterOperators(filterVariant: FilterVariant) {\r\n  const operatorMap: Record<\r\n    FilterVariant,\r\n    { label: string; value: FilterOperator }[]\r\n  > = {\r\n    text: dataTableConfig.textOperators,\r\n    number: dataTableConfig.numericOperators,\r\n    range: dataTableConfig.numericOperators,\r\n    date: dataTableConfig.dateOperators,\r\n    dateRange: dataTableConfig.dateOperators,\r\n    boolean: dataTableConfig.booleanOperators,\r\n    select: dataTableConfig.selectOperators,\r\n    multiSelect: dataTableConfig.multiSelectOperators,\r\n  };\r\n\r\n  return operatorMap[filterVariant] ?? dataTableConfig.textOperators;\r\n}\r\n\r\nexport function getDefaultFilterOperator(filterVariant: FilterVariant) {\r\n  const operators = getFilterOperators(filterVariant);\r\n\r\n  return operators[0]?.value ?? (filterVariant === \"text\" ? \"iLike\" : \"eq\");\r\n}\r\n\r\nexport function getValidFilters<TData>(\r\n  filters: ExtendedColumnFilter<TData>[],\r\n): ExtendedColumnFilter<TData>[] {\r\n  return filters.filter(\r\n    (filter) =>\r\n      filter.operator === \"isEmpty\" ||\r\n      filter.operator === \"isNotEmpty\" ||\r\n      (Array.isArray(filter.value)\r\n        ? filter.value.length > 0\r\n        : filter.value !== \"\" &&\r\n          filter.value !== null &&\r\n          filter.value !== undefined),\r\n  );\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/format.ts",
      "content": "export function formatDate(\n  date: Date | string | number | undefined,\n  opts: Intl.DateTimeFormatOptions = {},\n) {\n  if (!date) return \"\";\n\n  try {\n    return new Intl.DateTimeFormat(\"en-US\", {\n      month: opts.month ?? \"long\",\n      day: opts.day ?? \"numeric\",\n      year: opts.year ?? \"numeric\",\n      ...opts,\n    }).format(new Date(date));\n  } catch (_err) {\n    return \"\";\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/id.ts",
      "content": "import { customAlphabet } from \"nanoid\";\n\nconst prefixes: Record<string, unknown> = {};\n\ninterface GenerateIdOptions {\n  length?: number;\n  separator?: string;\n}\n\nexport function generateId(\n  prefixOrOptions?: keyof typeof prefixes | GenerateIdOptions,\n  inputOptions: GenerateIdOptions = {},\n) {\n  const finalOptions =\n    typeof prefixOrOptions === \"object\" ? prefixOrOptions : inputOptions;\n\n  const prefix =\n    typeof prefixOrOptions === \"object\" ? undefined : prefixOrOptions;\n\n  const { length = 12, separator = \"_\" } = finalOptions;\n  const id = customAlphabet(\n    \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n    length,\n  )();\n\n  return prefix && prefix in prefixes\n    ? `${prefixes[prefix]}${separator}${id}`\n    : id;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/parsers.ts",
      "content": "import { createParser } from \"nuqs/server\";\nimport { z } from \"zod\";\n\nimport { dataTableConfig } from \"@/config/data-table\";\n\nimport type {\n  ExtendedColumnFilter,\n  ExtendedColumnSort,\n} from \"@/types/data-table\";\n\nconst sortingItemSchema = z.object({\n  id: z.string(),\n  desc: z.boolean(),\n});\n\nexport const getSortingStateParser = <TData>(\n  columnIds?: string[] | Set<string>,\n) => {\n  const validKeys = columnIds\n    ? columnIds instanceof Set\n      ? columnIds\n      : new Set(columnIds)\n    : null;\n\n  return createParser({\n    parse: (value) => {\n      try {\n        const parsed = JSON.parse(value);\n        const result = z.array(sortingItemSchema).safeParse(parsed);\n\n        if (!result.success) return null;\n\n        if (validKeys && result.data.some((item) => !validKeys.has(item.id))) {\n          return null;\n        }\n\n        return result.data as ExtendedColumnSort<TData>[];\n      } catch {\n        return null;\n      }\n    },\n    serialize: (value) => JSON.stringify(value),\n    eq: (a, b) =>\n      a.length === b.length &&\n      a.every(\n        (item, index) =>\n          item.id === b[index]?.id && item.desc === b[index]?.desc,\n      ),\n  });\n};\n\nconst filterItemSchema = z.object({\n  id: z.string(),\n  value: z.union([z.string(), z.array(z.string())]),\n  variant: z.enum(dataTableConfig.filterVariants),\n  operator: z.enum(dataTableConfig.operators),\n  filterId: z.string(),\n});\n\nexport type FilterItemSchema = z.infer<typeof filterItemSchema>;\n\nexport const getFiltersStateParser = <TData>(\n  columnIds?: string[] | Set<string>,\n) => {\n  const validKeys = columnIds\n    ? columnIds instanceof Set\n      ? columnIds\n      : new Set(columnIds)\n    : null;\n\n  return createParser({\n    parse: (value) => {\n      try {\n        const parsed = JSON.parse(value);\n        const result = z.array(filterItemSchema).safeParse(parsed);\n\n        if (!result.success) return null;\n\n        if (validKeys && result.data.some((item) => !validKeys.has(item.id))) {\n          return null;\n        }\n\n        return result.data as ExtendedColumnFilter<TData>[];\n      } catch {\n        return null;\n      }\n    },\n    serialize: (value) => JSON.stringify(value),\n    eq: (a, b) =>\n      a.length === b.length &&\n      a.every(\n        (filter, index) =>\n          filter.id === b[index]?.id &&\n          filter.value === b[index]?.value &&\n          filter.variant === b[index]?.variant &&\n          filter.operator === b[index]?.operator,\n      ),\n  });\n};\n",
      "type": "registry:lib"
    },
    {
      "path": "src/config/data-table.ts",
      "content": "export type DataTableConfig = typeof dataTableConfig;\n\nexport const dataTableConfig = {\n  textOperators: [\n    { label: \"Contains\", value: \"iLike\" as const },\n    { label: \"Does not contain\", value: \"notILike\" as const },\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  numericOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is less than\", value: \"lt\" as const },\n    { label: \"Is less than or equal to\", value: \"lte\" as const },\n    { label: \"Is greater than\", value: \"gt\" as const },\n    { label: \"Is greater than or equal to\", value: \"gte\" as const },\n    { label: \"Is between\", value: \"isBetween\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  dateOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is before\", value: \"lt\" as const },\n    { label: \"Is after\", value: \"gt\" as const },\n    { label: \"Is on or before\", value: \"lte\" as const },\n    { label: \"Is on or after\", value: \"gte\" as const },\n    { label: \"Is between\", value: \"isBetween\" as const },\n    { label: \"Is relative to today\", value: \"isRelativeToToday\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  selectOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  multiSelectOperators: [\n    { label: \"Has any of\", value: \"inArray\" as const },\n    { label: \"Has none of\", value: \"notInArray\" as const },\n    { label: \"Is empty\", value: \"isEmpty\" as const },\n    { label: \"Is not empty\", value: \"isNotEmpty\" as const },\n  ],\n  booleanOperators: [\n    { label: \"Is\", value: \"eq\" as const },\n    { label: \"Is not\", value: \"ne\" as const },\n  ],\n  sortOrders: [\n    { label: \"Asc\", value: \"asc\" as const },\n    { label: \"Desc\", value: \"desc\" as const },\n  ],\n  filterVariants: [\n    \"text\",\n    \"number\",\n    \"range\",\n    \"date\",\n    \"dateRange\",\n    \"boolean\",\n    \"select\",\n    \"multiSelect\",\n  ] as const,\n  operators: [\n    \"iLike\",\n    \"notILike\",\n    \"eq\",\n    \"ne\",\n    \"inArray\",\n    \"notInArray\",\n    \"isEmpty\",\n    \"isNotEmpty\",\n    \"lt\",\n    \"lte\",\n    \"gt\",\n    \"gte\",\n    \"isBetween\",\n    \"isRelativeToToday\",\n  ] as const,\n  joinOperators: [\"and\", \"or\"] as const,\n};\n",
      "type": "registry:file",
      "target": "src/config/data-table.ts"
    },
    {
      "path": "src/types/data-table.ts",
      "content": "import type { ColumnSort, Row, RowData } from \"@tanstack/react-table\";\r\nimport type { DataTableConfig } from \"@/config/data-table\";\r\nimport type { FilterItemSchema } from \"@/lib/parsers\";\r\n\r\ndeclare module \"@tanstack/react-table\" {\r\n  // biome-ignore lint/correctness/noUnusedVariables: TData is used in the TableMeta interface\r\n  interface TableMeta<TData extends RowData> {\r\n    queryKeys?: QueryKeys;\r\n  }\r\n\r\n  // biome-ignore lint/correctness/noUnusedVariables: TData and TValue are used in the ColumnMeta interface\r\n  interface ColumnMeta<TData extends RowData, TValue> {\r\n    label?: string;\r\n    placeholder?: string;\r\n    variant?: FilterVariant;\r\n    options?: Option[];\r\n    range?: [number, number];\r\n    unit?: string;\r\n    icon?: React.FC<React.SVGProps<SVGSVGElement>>;\r\n  }\r\n}\r\n\r\nexport interface QueryKeys {\r\n  page: string;\r\n  perPage: string;\r\n  sort: string;\r\n  filters: string;\r\n  joinOperator: string;\r\n}\r\n\r\nexport interface Option {\r\n  label: string;\r\n  value: string;\r\n  count?: number;\r\n  icon?: React.FC<React.SVGProps<SVGSVGElement>>;\r\n}\r\n\r\nexport type FilterOperator = DataTableConfig[\"operators\"][number];\r\nexport type FilterVariant = DataTableConfig[\"filterVariants\"][number];\r\nexport type JoinOperator = DataTableConfig[\"joinOperators\"][number];\r\n\r\nexport interface ExtendedColumnSort<TData> extends Omit<ColumnSort, \"id\"> {\r\n  id: Extract<keyof TData, string>;\r\n}\r\n\r\nexport interface ExtendedColumnFilter<TData> extends FilterItemSchema {\r\n  id: Extract<keyof TData, string>;\r\n}\r\n\r\nexport interface DataTableRowAction<TData> {\r\n  row: Row<TData>;\r\n  variant: \"update\" | \"delete\";\r\n}\r\n",
      "type": "registry:file",
      "target": "src/types/data-table.ts"
    }
  ]
}